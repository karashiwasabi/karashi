----- C:\Dev\KARASHI\dat\branch.go -----
// File: dat/branch.go
package dat

import (
	"database/sql"
	"fmt"
	"karashi/db"
	"karashi/model"
	"karashi/tani"
	"strconv"
)

// ExecuteDatBranching is the main branching logic for DAT records.
func ExecuteDatBranching(conn *sql.DB, prec model.ARInput) (model.ARInput, error) {
	key := prec.Ajc
	if key == "0000000000000" {
		key = fmt.Sprintf("9999999999999%s", prec.Apname)
	}

	master, err := db.GetMaMasterByCode(conn, key)
	if err != nil {
		return model.ARInput{}, err
	}
	if master != nil {
		if prec.Ajc == "0000000000000" {
			return processDatBranch1(prec, master)
		}
		return processDatBranch3(prec, master)
	}

	jcshms, err := db.GetJcshmsByJan(conn, prec.Ajc)
	if err != nil {
		return model.ARInput{}, err
	}
	if jcshms != nil {
		if jcshms.JC009 != "" {
			return processDatBranch4(conn, prec, jcshms)
		}
		return processDatBranch5(conn, prec, jcshms)
	}

	if prec.Ajc == "0000000000000" {
		return processDatBranch2(conn, prec)
	}
	return processDatBranch6(conn, prec)
}

// --- Helper Functions for Each Branch ---

// mrdat1: No JAN, ma_master exists
func processDatBranch1(prec model.ARInput, master *model.MaMaster) (model.ARInput, error) {
	prec.Ayj = master.MA009
	prec.Apname = master.MA018 // <-- Fix: Add product name
	prec.Ama = "1"
	prec.Apkg = fmt.Sprintf("%s %g%s", master.MA037, master.MA044, tani.ResolveName(master.MA039))
	prec.Amaker = master.MA030
	return prec, nil
}

// mrdat2: No JAN, no ma_master
func processDatBranch2(conn *sql.DB, prec model.ARInput) (model.ARInput, error) {
	newYj, err := db.NextSequence(conn, "MA2Y")
	if err != nil {
		return model.ARInput{}, err
	}
	prec.Ajc = fmt.Sprintf("9999999999999%s", prec.Apname)
	prec.Ayj = newYj
	prec.Ama = "2"

	masterInput := model.MaMasterInput{MA000: prec.Ajc, MA009: prec.Ayj, MA018: prec.Apname}
	if err := db.CreateMaMaster(conn, masterInput); err != nil {
		return model.ARInput{}, err
	}
	return prec, nil
}

// mrdat3: JAN exists, ma_master exists
func processDatBranch3(prec model.ARInput, master *model.MaMaster) (model.ARInput, error) {
	prec.Ayj = master.MA009
	prec.Apname = master.MA018 // <-- Fix: Add product name
	prec.Akana = master.MA022
	prec.Amaker = master.MA030
	prec.Ayjpu = master.MA044
	prec.Ajpu = master.MA133
	prec.Ayjunitnm = tani.ResolveName(master.MA039)
	prec.Ajanqty = prec.Adatqty * master.MA133
	prec.Ayjqty = prec.Adatqty * prec.Ayjpu

	ajanunitcode := strconv.Itoa(master.MA132)
	var ajanunitnm string
	if ajanunitcode == "0" {
		ajanunitnm = prec.Ayjunitnm
	} else {
		ajanunitnm = tani.ResolveName(ajanunitcode)
	}
	prec.Ajanunitcode = ajanunitcode
	prec.Ajanunitnm = ajanunitnm

	pkg := fmt.Sprintf("%s %g%s", master.MA037, master.MA044, prec.Ayjunitnm)
	if master.MA131 != 0 && master.MA133 != 0 {
		pkg += fmt.Sprintf(" (%g%s×%g%s)",
			master.MA131, prec.Ayjunitnm,
			master.MA133, ajanunitnm)
	}
	prec.Apkg = pkg

	prec.Ama = "3"
	return prec, nil
}

// mrdat4: JAN exists, no ma_master, JCSHMS exists (with YJ)
func processDatBranch4(conn *sql.DB, prec model.ARInput, jcshms *db.JCShms) (model.ARInput, error) {
	masterInput := model.MaMasterInput{
		MA000: prec.Ajc, MA009: jcshms.JC009, MA018: jcshms.JC018, MA022: jcshms.JC022, MA030: jcshms.JC030,
		MA037: jcshms.JC037, MA039: jcshms.JC039, MA044: jcshms.JC044, MA061: jcshms.JC061,
		MA062: jcshms.JC062, MA063: jcshms.JC063, MA064: jcshms.JC064, MA065: jcshms.JC065,
		MA066: jcshms.JC066, MA131: jcshms.JA006.Float64, MA133: jcshms.JA008.Float64,
	}
	if jcshms.JA007.Valid {
		if val, err := strconv.Atoi(jcshms.JA007.String); err == nil {
			masterInput.MA132 = val
		}
	}
	if err := db.CreateMaMaster(conn, masterInput); err != nil {
		return model.ARInput{}, err
	}

	prec.Ayj = jcshms.JC009
	prec.Apname = jcshms.JC018 // <-- Fix: Add product name
	prec.Akana = jcshms.JC022
	prec.Amaker = jcshms.JC030
	prec.Ayjpu = jcshms.JC044
	prec.Ajpu = jcshms.JA008.Float64
	prec.Ayjunitnm = tani.ResolveName(jcshms.JC039)
	if jcshms.JA008.Valid {
		prec.Ajanqty = prec.Adatqty * jcshms.JA008.Float64
	}
	prec.Ayjqty = prec.Adatqty * prec.Ayjpu

	ajanunitcode := jcshms.JA007.String
	var ajanunitnm string
	if ajanunitcode == "0" || ajanunitcode == "" {
		ajanunitnm = prec.Ayjunitnm
	} else {
		ajanunitnm = tani.ResolveName(ajanunitcode)
	}
	prec.Ajanunitcode = ajanunitcode
	prec.Ajanunitnm = ajanunitnm

	pkg := fmt.Sprintf("%s %g%s", jcshms.JC037, jcshms.JC044, prec.Ayjunitnm)
	if jcshms.JA006.Valid && jcshms.JA008.Valid {
		pkg += fmt.Sprintf(" (%g%s×%g%s)",
			jcshms.JA006.Float64, prec.Ayjunitnm,
			jcshms.JA008.Float64, ajanunitnm)
	}
	prec.Apkg = pkg

	prec.Ama = "4"
	return prec, nil
}

// mrdat5: JAN exists, no ma_master, JCSHMS exists (no YJ)
func processDatBranch5(conn *sql.DB, prec model.ARInput, jcshms *db.JCShms) (model.ARInput, error) {
	newYj, err := db.NextSequence(conn, "MA2Y")
	if err != nil {
		return model.ARInput{}, err
	}
	prec.Ayj = newYj
	prec.Apname = jcshms.JC018 // <-- Fix: Add product name
	prec.Akana = jcshms.JC022
	prec.Amaker = jcshms.JC030
	prec.Ayjpu = jcshms.JC044
	prec.Ajpu = jcshms.JA008.Float64
	prec.Ayjunitnm = tani.ResolveName(jcshms.JC039)
	if jcshms.JA008.Valid {
		prec.Ajanqty = prec.Adatqty * jcshms.JA008.Float64
	}
	prec.Ayjqty = prec.Adatqty * prec.Ayjpu

	ajanunitcode := jcshms.JA007.String
	var ajanunitnm string
	if ajanunitcode == "0" || ajanunitcode == "" {
		ajanunitnm = prec.Ayjunitnm
	} else {
		ajanunitnm = tani.ResolveName(ajanunitcode)
	}
	prec.Ajanunitcode = ajanunitcode
	prec.Ajanunitnm = ajanunitnm

	pkg := fmt.Sprintf("%s %g%s", jcshms.JC037, jcshms.JC044, prec.Ayjunitnm)
	if jcshms.JA006.Valid && jcshms.JA008.Valid {
		pkg += fmt.Sprintf(" (%g%s×%g%s)",
			jcshms.JA006.Float64, prec.Ayjunitnm,
			jcshms.JA008.Float64, ajanunitnm)
	}
	prec.Apkg = pkg

	masterInput := model.MaMasterInput{
		MA000: prec.Ajc, MA009: prec.Ayj, MA018: jcshms.JC018, MA022: jcshms.JC022, MA030: jcshms.JC030,
		MA037: jcshms.JC037, MA039: jcshms.JC039, MA044: jcshms.JC044, MA061: jcshms.JC061,
		MA062: jcshms.JC062, MA063: jcshms.JC063, MA064: jcshms.JC064, MA065: jcshms.JC065,
		MA066: jcshms.JC066, MA131: jcshms.JA006.Float64, MA133: jcshms.JA008.Float64,
	}
	if jcshms.JA007.Valid {
		if val, err := strconv.Atoi(jcshms.JA007.String); err == nil {
			masterInput.MA132 = val
		}
	}
	if err := db.CreateMaMaster(conn, masterInput); err != nil {
		return model.ARInput{}, err
	}

	prec.Ama = "5"
	return prec, nil
}

// mrdat6: JAN exists, no ma_master, no JCSHMS
func processDatBranch6(conn *sql.DB, prec model.ARInput) (model.ARInput, error) {
	newYj, err := db.NextSequence(conn, "MA2Y")
	if err != nil {
		return model.ARInput{}, err
	}
	prec.Ayj = newYj
	prec.Ama = "6"

	masterInput := model.MaMasterInput{MA000: prec.Ajc, MA009: prec.Ayj, MA018: prec.Apname}
	if err := db.CreateMaMaster(conn, masterInput); err != nil {
		return model.ARInput{}, err
	}
	return prec, nil
}


----- C:\Dev\KARASHI\dat\handler.go -----
// File: dat/handler.go
package dat

import (
	"database/sql"
	"encoding/json"
	"karashi/db"
	"karashi/model"
	"log"
	"net/http"
	"strconv"
)

func UploadDatHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		if r.Method != http.MethodPost {
			http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
			return
		}
		file, _, err := r.FormFile("file")
		if err != nil {
			http.Error(w, "File upload error", http.StatusBadRequest)
			return
		}
		defer file.Close()

		parsedRecords, err := ParseDat(file)
		if err != nil {
			http.Error(w, "DAT parse error", http.StatusInternalServerError)
			log.Printf("dat.ParseDat error: %v", err)
			return
		}

		var finalRecords []model.ARInput
		for _, rec := range parsedRecords {
			// 1. Convert ParsedDat to the common ARInput struct
			datqty, _ := strconv.ParseFloat(rec.Quantity, 64)
			unitprice, _ := strconv.ParseFloat(rec.UnitPrice, 64)
			subtotal, _ := strconv.ParseFloat(rec.Subtotal, 64)
			expdate, _ := strconv.ParseFloat(rec.ExpiryDate, 64)
			flag, _ := strconv.Atoi(rec.DeliveryFlag)

			ar := model.ARInput{
				Adate:      rec.DatDate,
				Apcode:     rec.WholesaleCode,
				Arpnum:     rec.ReceiptNumber,
				Alnum:      rec.LineNumber,
				Aflag:      flag,
				Ajc:        rec.JanCode,
				Apname:     rec.ProductName,
				Adatqty:    datqty,
				Aunitprice: unitprice,
				Asubtotal:  subtotal,
				Aexpdate:   expdate,
				Alot:       rec.LotNumber,
			}

			// 2. Call the branching logic
			processedAr, err := ExecuteDatBranching(conn, ar)
			if err != nil {
				log.Printf("ExecuteDatBranching failed for JAN %s: %v", ar.Ajc, err)
				continue
			}
			finalRecords = append(finalRecords, processedAr)
		}

		// 3. Persist the final records to the a_records table
		if len(finalRecords) > 0 {
			if err := db.PersistARecords(conn, finalRecords); err != nil {
				log.Printf("PersistARecords error: %v", err)
				http.Error(w, "internal server error", http.StatusInternalServerError)
				return
			}
		}

		// Return the final, processed data as JSON to the frontend
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		json.NewEncoder(w).Encode(map[string]interface{}{
			"message": "Parsed and processed DAT file successfully",
			"records": finalRecords,
		})
	}
}


----- C:\Dev\KARASHI\dat\parser.go -----
// File: dat/parser.go
package dat

import (
	"bufio"
	"io"
	"strings"

	"golang.org/x/text/encoding/japanese"
	"golang.org/x/text/transform"
)

// ParseDatは、固定長のDATファイルからレコードを抽出します。
func ParseDat(r io.Reader) ([]ParsedDat, error) {
	scanner := bufio.NewScanner(r)
	var records []ParsedDat
	var currentWholesale string

	for scanner.Scan() {
		line := scanner.Text() // Shift_JISのままの行データ
		if len(line) == 0 {
			continue
		}

		switch line[0:1] {
		case "S":
			if len(line) >= 13 {
				currentWholesale = strings.TrimSpace(line[2:13])
			}
		case "D":
			if len(line) < 121 {
				line += strings.Repeat(" ", 121-len(line))
			}

			// 製品名フィールドをShift_JISのまま切り出し、UTF-8にデコード
			productNameSJIS := line[38:78]
			utf8Bytes, _, _ := transform.Bytes(japanese.ShiftJIS.NewDecoder(), []byte(productNameSJIS))
			productNameUTF8 := strings.TrimSpace(string(utf8Bytes))

			rec := ParsedDat{
				WholesaleCode: currentWholesale,
				// vvv ここからが修正箇所 vvv
				DeliveryFlag: strings.TrimSpace(line[3:4]),  // 4文字目をフラグとして取得
				DatDate:      strings.TrimSpace(line[4:12]), // 5文字目からを日付として取得
				// ^^^ ここまで ^^^
				ReceiptNumber: strings.TrimSpace(line[12:22]),
				LineNumber:    strings.TrimSpace(line[22:24]),
				JanCode:       strings.TrimSpace(line[25:38]),
				ProductName:   productNameUTF8,
				Quantity:      strings.TrimSpace(line[78:83]),
				UnitPrice:     strings.TrimSpace(line[83:92]),
				Subtotal:      strings.TrimSpace(line[92:101]),
				ExpiryDate:    strings.TrimSpace(line[109:115]),
				LotNumber:     strings.TrimSpace(line[115:121]),
			}
			records = append(records, rec)
		}
	}
	return records, scanner.Err()
}


----- C:\Dev\KARASHI\dat\types.go -----
// File: dat/types.go
package dat

// ParsedDatは、DATファイルのD行からパースされたレコードを表します。
type ParsedDat struct {
	WholesaleCode string
	DatDate       string
	DeliveryFlag  string
	ReceiptNumber string
	LineNumber    string
	JanCode       string
	ProductName   string
	Quantity      string
	UnitPrice     string
	Subtotal      string
	ExpiryDate    string
	LotNumber     string
}

// MarshalJSON は不要になったため削除しました。


----- C:\Dev\KARASHI\db\a_records.go -----
// File: db/a_records.go
package db

import (
	"database/sql"
	"fmt"
	"karashi/model"
)

// PersistARecordsは、処理済みのレコードリストをDBに保存します。
func PersistARecords(conn *sql.DB, ars []model.ARInput) error {
	// 複数のレコードを効率的かつ安全に登録するため、トランザクションを開始します。
	tx, err := conn.Begin()
	if err != nil {
		return fmt.Errorf("failed to begin transaction: %w", err)
	}
	// 途中でエラーが発生した場合は、すべての変更を元に戻します。
	defer tx.Rollback()

	// a_recordsテーブルの全32列に対応したINSERT文を準備します。
	// INSERT OR REPLACE を使うことで、主キーが重複した場合でも新しいデータで上書きします。
	const q = `
INSERT OR REPLACE INTO a_records (
  adate, apcode, arpnum, alnum, aflag, ajc, ayj, apname, akana, apkg, amaker,
  adatqty, ajanqty, ajpu, ajanunitname, ajanunitcode, ayjqty, ayjpu, ayjunitname,
  aunitprice, asubtotal, ataxamount, ataxrate, aexpdate, alot,
  adokuyaku, agekiyaku, amayaku, akouseisinyaku, akakuseizai, akakuseizaigenryou,
  ama
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`

	stmt, err := tx.Prepare(q)
	if err != nil {
		return fmt.Errorf("failed to prepare statement: %w", err)
	}
	defer stmt.Close()

	// 受け取ったレコードのリストをループ処理で1件ずつデータベースに登録します。
	for _, ar := range ars {
		_, err := stmt.Exec(
			ar.Adate, ar.Apcode, ar.Arpnum, ar.Alnum, ar.Aflag, ar.Ajc, ar.Ayj, ar.Apname, ar.Akana, ar.Apkg, ar.Amaker,
			ar.Adatqty, ar.Ajanqty, ar.Ajpu, ar.Ajanunitnm, ar.Ajanunitcode, ar.Ayjqty, ar.Ayjpu, ar.Ayjunitnm,
			ar.Aunitprice, ar.Asubtotal, ar.Ataxamt, ar.Ataxrate, ar.Aexpdate, ar.Alot,
			ar.Adokuyaku, ar.Agekiyaku, ar.Amayaku, ar.Akouseisinyaku, ar.Akakuseizai, ar.Akakuseizaigenryou,
			ar.Ama,
		)
		if err != nil {
			// 1件でもエラーがあれば、全処理を中止してエラーを返します。
			return fmt.Errorf("failed to exec statement for ARInput (JAN: %s, Ama: %s): %w", ar.Ajc, ar.Ama, err)
		}
	}

	// すべての登録が成功した場合、トランザクションを確定します。
	return tx.Commit()
}


----- C:\Dev\KARASHI\db\exist.go -----
// File: db/exist.go
package db

import (
	"database/sql"
)

// ExistsByJan checks if ma_master.MA000 (JANコード) exists.
func ExistsByJan(conn *sql.DB, jan string) (bool, error) {
	const q = `
SELECT 1
  FROM ma_master
 WHERE MA000 = ?
 LIMIT 1`
	var dummy int
	err := conn.QueryRow(q, jan).Scan(&dummy)
	if err == sql.ErrNoRows {
		return false, nil
	}
	return err == nil, err
}

// ExistsByYj checks if ma_master.MA009 (YJコード) exists.
func ExistsByYj(conn *sql.DB, yj string) (bool, error) {
	const q = `
SELECT 1
  FROM ma_master
 WHERE MA009 = ?
 LIMIT 1`
	var dummy int
	err := conn.QueryRow(q, yj).Scan(&dummy)
	if err == sql.ErrNoRows {
		return false, nil
	}
	return err == nil, err
}


----- C:\Dev\KARASHI\db\inventory.go -----
// File: db/inventory.go
package db

import (
	"database/sql"
	"fmt"
	"karashi/model"
)

// PersistInventoryRecordsは、棚卸レコードのリストをDBに保存します。
func PersistInventoryRecords(conn *sql.DB, records []model.ARInput) error {
	tx, err := conn.Begin()
	if err != nil {
		return fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer tx.Rollback()

	// 同じ日付の古い棚卸データを一旦削除
	if len(records) > 0 {
		date := records[0].Adate
		if _, err := tx.Exec("DELETE FROM inventory WHERE inv_date = ?", date); err != nil {
			return fmt.Errorf("failed to delete old inventory data: %w", err)
		}
	}

	const q = `
INSERT OR IGNORE INTO inventory (
  inv_date, inv_jan_code, inv_yj_code, inv_product_name, inv_quantity
) VALUES (?, ?, ?, ?, ?)`

	stmt, err := tx.Prepare(q)
	if err != nil {
		return fmt.Errorf("failed to prepare statement: %w", err)
	}
	defer stmt.Close()

	for _, rec := range records {
		_, err := stmt.Exec(
			rec.Adate,
			rec.Ajc,
			rec.Ayj,
			rec.Apname,
			rec.Ajanqty, // 在庫数は Ajanqty を使う
		)
		if err != nil {
			return fmt.Errorf("failed to exec statement for inventory (JAN: %s): %w", rec.Ajc, err)
		}
	}

	return tx.Commit()
}


----- C:\Dev\KARASHI\db\jcshms.go -----
// File: db/jcshms.go
package db

import (
	"database/sql"
	"fmt"
)

// JCShmsは、jcshmsとjancodeテーブルを結合した結果を保持する構造体です。
type JCShms struct {
	JC009 string
	JC018 string
	JC022 string
	JC030 string
	JC037 string
	JC039 string
	JC044 float64 // vvv 修正点: stringからfloat64へ
	JC061 int
	JC062 int
	JC063 int
	JC064 int
	JC065 int
	JC066 int
	// vvv ここから下がjancode由来の修正点 vvv
	JA006 sql.NullFloat64 // JAN側 包装内数量
	JA007 sql.NullString  // JAN側 単位コード (文字列のまま)
	JA008 sql.NullFloat64 // JAN側 包装単位での数量
}

// GetJcshmsByJanは、JANコードを元にjcshmsとjancodeのデータをそれぞれ検索し、結果を結合します。
func GetJcshmsByJan(conn *sql.DB, jan string) (*JCShms, error) {
	// 最終的に返すための構造体
	finalRec := &JCShms{}
	found := false // どちらかのテーブルでデータが見つかったか

	// --- 1. jcshmsテーブルをJC000で検索 ---
	var jcshmsPart struct {
		JC009, JC018, JC022, JC030, JC037, JC039 string
		JC044                                    float64
		JC061, JC062, JC063, JC064, JC065, JC066 int
	}
	const q1 = `SELECT JC009, JC018, JC022, JC030, JC037, JC039, JC044, JC061, JC062, JC063, JC064, JC065, JC066
	              FROM jcshms WHERE JC000 = ? LIMIT 1`
	err1 := conn.QueryRow(q1, jan).Scan(
		&jcshmsPart.JC009, &jcshmsPart.JC018, &jcshmsPart.JC022, &jcshmsPart.JC030,
		&jcshmsPart.JC037, &jcshmsPart.JC039, &jcshmsPart.JC044, &jcshmsPart.JC061,
		&jcshmsPart.JC062, &jcshmsPart.JC063, &jcshmsPart.JC064, &jcshmsPart.JC065, &jcshmsPart.JC066,
	)
	if err1 != nil && err1 != sql.ErrNoRows {
		return nil, fmt.Errorf("jcshms search failed: %w", err1)
	}
	if err1 == nil {
		found = true
		finalRec.JC009 = jcshmsPart.JC009
		finalRec.JC018 = jcshmsPart.JC018
		finalRec.JC022 = jcshmsPart.JC022
		finalRec.JC030 = jcshmsPart.JC030
		finalRec.JC037 = jcshmsPart.JC037
		finalRec.JC039 = jcshmsPart.JC039
		finalRec.JC044 = jcshmsPart.JC044
		finalRec.JC061 = jcshmsPart.JC061
		finalRec.JC062 = jcshmsPart.JC062
		finalRec.JC063 = jcshmsPart.JC063
		finalRec.JC064 = jcshmsPart.JC064
		finalRec.JC065 = jcshmsPart.JC065
		finalRec.JC066 = jcshmsPart.JC066
	}

	// --- 2. jancodeテーブルをJA001で検索 ---
	const q2 = `SELECT JA006, JA007, JA008 FROM jancode WHERE JA001 = ? LIMIT 1`
	err2 := conn.QueryRow(q2, jan).Scan(&finalRec.JA006, &finalRec.JA007, &finalRec.JA008)
	if err2 != nil && err2 != sql.ErrNoRows {
		return nil, fmt.Errorf("jancode search failed: %w", err2)
	}
	if err2 == nil {
		found = true
	}

	// --- 3. どちらの検索でも見つからなければデータなしと判断 ---
	if !found {
		return nil, nil // Not found
	}

	return finalRec, nil
}


----- C:\Dev\KARASHI\db\ma_master.go -----
// File: db/ma_master.go
package db

import (
	"database/sql"
	"fmt"
	"karashi/model" // Import the new model package
)

// The MaMaster and MaMasterInput structs are now defined in model/types.go

// GetMaMasterByCode fetches a ma_master record by its primary key (MA000).
func GetMaMasterByCode(conn *sql.DB, code string) (*model.MaMaster, error) {
	const q = `SELECT MA000, MA009, MA018, MA022, MA030, MA037, MA039, MA044, MA061, MA062, MA063, MA064, MA065, MA066, MA131, MA132, MA133 FROM ma_master WHERE MA000 = ? LIMIT 1`
	var m model.MaMaster
	err := conn.QueryRow(q, code).Scan(
		&m.MA000, &m.MA009, &m.MA018, &m.MA022, &m.MA030, &m.MA037,
		&m.MA039, &m.MA044, &m.MA061, &m.MA062, &m.MA063, &m.MA064,
		&m.MA065, &m.MA066, &m.MA131, &m.MA132, &m.MA133,
	)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, err
	}
	return &m, nil
}

// CreateMaMaster creates a new master record in the ma_master table.
func CreateMaMaster(conn *sql.DB, rec model.MaMasterInput) error {

	const q = `
INSERT INTO ma_master (
  MA000, MA009, MA018, MA022, MA030, MA037, MA039, MA044, 
  MA061, MA062, MA063, MA064, MA065, MA066,
  MA131, MA132, MA133
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`

	_, err := conn.Exec(q,
		rec.MA000, rec.MA009, rec.MA018, rec.MA022, rec.MA030, rec.MA037, rec.MA039, rec.MA044,
		rec.MA061, rec.MA062, rec.MA063, rec.MA064, rec.MA065, rec.MA066,
		rec.MA131, rec.MA132, rec.MA133,
	)
	if err != nil {
		return fmt.Errorf("CreateMaMaster failed: %w", err)
	}
	return nil
}


----- C:\Dev\KARASHI\db\sequence.go -----
package db

import (
	"database/sql"
	"fmt"
)

// NextSequence は code_sequences テーブルをトランザクション内でロックして
// last_no をインクリメントし、"MA2Y00000001" のような文字列を返します。
func NextSequence(conn *sql.DB, name string) (string, error) {
	tx, err := conn.Begin()
	if err != nil {
		return "", err
	}
	defer tx.Rollback()

	var last int
	err = tx.QueryRow(
		"SELECT last_no FROM code_sequences WHERE name = ?",
		name,
	).Scan(&last)
	if err != nil {
		return "", err
	}

	last++
	_, err = tx.Exec(
		"UPDATE code_sequences SET last_no = ? WHERE name = ?",
		last, name,
	)
	if err != nil {
		return "", err
	}

	if err := tx.Commit(); err != nil {
		return "", err
	}

	// フォーマットは "MA2Y"+8桁ゼロ埋め
	return fmt.Sprintf("%s%08d", name, last), nil
}

// ExistsMA2ByJan は ma_master テーブルに MA000=key のレコードがあるかを返します。
func ExistsMA2ByJan(conn *sql.DB, key string) (bool, error) {
	const q = `
SELECT 1
  FROM ma_master
 WHERE MA000 = ?
 LIMIT 1`
	var dummy int
	err := conn.QueryRow(q, key).Scan(&dummy)
	if err == sql.ErrNoRows {
		return false, nil
	}
	if err != nil {
		return false, err
	}
	return true, nil
}


----- C:\Dev\KARASHI\inventory\branch.go -----
// File: inventory/branch.go
package inventory

import (
	"database/sql"
	"fmt"
	"karashi/db"
	"karashi/model"
	"karashi/tani"
	"strconv"
)

// ExecuteInventoryBranchingは、棚卸レコードを正しい分岐ロジックで処理します。
func ExecuteInventoryBranching(conn *sql.DB, rec model.ARInput) (model.ARInput, error) {
	// --- ケース1: JANコードが存在する場合 ---
	if rec.Ajc != "" {
		master, err := db.GetMaMasterByCode(conn, rec.Ajc)
		if err != nil {
			return model.ARInput{}, err
		}
		if master != nil {
			return processInvBranch1(rec, master)
		}

		jcshms, err := db.GetJcshmsByJan(conn, rec.Ajc)
		if err != nil {
			return model.ARInput{}, err
		}
		if jcshms != nil {
			if jcshms.JC009 != "" {
				return processInvBranch2(conn, rec, jcshms) // Branch 2
			}
			return processInvBranch3(conn, rec, jcshms) // Branch 3
		}

		return processInvBranch4(conn, rec) // Branch 4
	}

	// --- ケース2: JANコードが無く、YJコードが存在する場合 ---
	if rec.Ayj != "" {
		return processInvBranch5(conn, rec) // Branch 5
	}

	return rec, nil
}

// --- 各分岐のヘルパー関数 ---

// Branch 1: JANあり, ma_masterあり
func processInvBranch1(rec model.ARInput, master *model.MaMaster) (model.ARInput, error) {
	rec.Ayj = master.MA009
	rec.Apname = master.MA018
	rec.Amaker = master.MA030
	rec.Ayjpu = master.MA044
	rec.Ajpu = master.MA133

	// vvv 包装文字列と単位名のロジックを追加 vvv
	ayjunitnm := tani.ResolveName(master.MA039)
	ajanunitcode := strconv.Itoa(master.MA132)
	var ajanunitnm string
	if ajanunitcode == "0" {
		ajanunitnm = ayjunitnm
	} else {
		ajanunitnm = tani.ResolveName(ajanunitcode)
	}
	rec.Ajanunitnm = ajanunitnm
	rec.Ayjunitnm = ayjunitnm

	pkg := fmt.Sprintf("%s %g%s", master.MA037, master.MA044, ayjunitnm)
	if master.MA131 != 0 && master.MA133 != 0 {
		pkg += fmt.Sprintf(" (%g%s×%g%s)", master.MA131, ayjunitnm, master.MA133, ajanunitnm)
	}
	rec.Apkg = pkg
	// ^^^ ここまで ^^^

	return rec, nil
}

// Branch 2: JANあり, ma_masterなし, JCSHMSあり (YJあり)
func processInvBranch2(conn *sql.DB, rec model.ARInput, jcshms *db.JCShms) (model.ARInput, error) {
	rec.Ayj = jcshms.JC009
	rec.Apname = jcshms.JC018
	rec.Amaker = jcshms.JC030
	rec.Ayjpu = jcshms.JC044
	rec.Ajpu = jcshms.JA008.Float64

	// vvv 包装文字列と単位名のロジックを追加 vvv
	ayjunitnm := tani.ResolveName(jcshms.JC039)
	ajanunitcode := jcshms.JA007.String
	var ajanunitnm string
	if ajanunitcode == "0" || ajanunitcode == "" {
		ajanunitnm = ayjunitnm
	} else {
		ajanunitnm = tani.ResolveName(ajanunitcode)
	}
	rec.Ajanunitnm = ajanunitnm
	rec.Ayjunitnm = ayjunitnm

	pkg := fmt.Sprintf("%s %g%s", jcshms.JC037, jcshms.JC044, ayjunitnm)
	if jcshms.JA006.Valid && jcshms.JA008.Valid {
		pkg += fmt.Sprintf(" (%g%s×%g%s)", jcshms.JA006.Float64, ayjunitnm, jcshms.JA008.Float64, ajanunitnm)
	}
	rec.Apkg = pkg
	// ^^^ ここまで ^^^

	masterInput := model.MaMasterInput{
		MA000: rec.Ajc, MA009: jcshms.JC009, MA018: jcshms.JC018, MA022: jcshms.JC022, MA030: jcshms.JC030,
		MA037: jcshms.JC037, MA039: jcshms.JC039, MA044: jcshms.JC044, MA061: jcshms.JC061,
		MA062: jcshms.JC062, MA063: jcshms.JC063, MA064: jcshms.JC064, MA065: jcshms.JC065,
		MA066: jcshms.JC066, MA131: jcshms.JA006.Float64, MA133: jcshms.JA008.Float64,
	}
	if jcshms.JA007.Valid {
		if val, err := strconv.Atoi(jcshms.JA007.String); err == nil {
			masterInput.MA132 = val
		}
	}
	if err := db.CreateMaMaster(conn, masterInput); err != nil {
		return model.ARInput{}, err
	}
	return rec, nil
}

// Branch 3: JANあり, ma_masterなし, JCSHMSあり (YJなし)
func processInvBranch3(conn *sql.DB, rec model.ARInput, jcshms *db.JCShms) (model.ARInput, error) {
	newYj, err := db.NextSequence(conn, "MA2Y")
	if err != nil {
		return model.ARInput{}, err
	}
	rec.Ayj = newYj
	rec.Apname = jcshms.JC018
	rec.Amaker = jcshms.JC030
	rec.Ayjpu = jcshms.JC044
	rec.Ajpu = jcshms.JA008.Float64

	// vvv 包装文字列と単位名のロジックを追加 vvv
	ayjunitnm := tani.ResolveName(jcshms.JC039)
	ajanunitcode := jcshms.JA007.String
	var ajanunitnm string
	if ajanunitcode == "0" || ajanunitcode == "" {
		ajanunitnm = ayjunitnm
	} else {
		ajanunitnm = tani.ResolveName(ajanunitcode)
	}
	rec.Ajanunitnm = ajanunitnm
	rec.Ayjunitnm = ayjunitnm

	pkg := fmt.Sprintf("%s %g%s", jcshms.JC037, jcshms.JC044, ayjunitnm)
	if jcshms.JA006.Valid && jcshms.JA008.Valid {
		pkg += fmt.Sprintf(" (%g%s×%g%s)", jcshms.JA006.Float64, ayjunitnm, jcshms.JA008.Float64, ajanunitnm)
	}
	rec.Apkg = pkg
	// ^^^ ここまで ^^^

	masterInput := model.MaMasterInput{
		MA000: rec.Ajc, MA009: newYj, MA018: jcshms.JC018, MA022: jcshms.JC022, MA030: jcshms.JC030,
		MA037: jcshms.JC037, MA039: jcshms.JC039, MA044: jcshms.JC044, MA061: jcshms.JC061,
		MA062: jcshms.JC062, MA063: jcshms.JC063, MA064: jcshms.JC064, MA065: jcshms.JC065,
		MA066: jcshms.JC066, MA131: jcshms.JA006.Float64, MA133: jcshms.JA008.Float64,
	}
	if jcshms.JA007.Valid {
		if val, err := strconv.Atoi(jcshms.JA007.String); err == nil {
			masterInput.MA132 = val
		}
	}
	if err := db.CreateMaMaster(conn, masterInput); err != nil {
		return model.ARInput{}, err
	}
	return rec, nil
}

// Branch 4: JANあり, どのマスターにもない
func processInvBranch4(conn *sql.DB, rec model.ARInput) (model.ARInput, error) {
	newYj, err := db.NextSequence(conn, "MA2Y")
	if err != nil {
		return model.ARInput{}, err
	}
	rec.Ayj = newYj

	masterInput := model.MaMasterInput{MA000: rec.Ajc, MA009: newYj, MA018: rec.Apname}
	if err := db.CreateMaMaster(conn, masterInput); err != nil {
		return model.ARInput{}, err
	}
	return rec, nil
}

// Branch 5: JANなし, YJあり
func processInvBranch5(conn *sql.DB, rec model.ARInput) (model.ARInput, error) {
	newJan := fmt.Sprintf("9999999999999%s", rec.Apname)
	rec.Ajc = newJan

	existingMaster, err := db.GetMaMasterByCode(conn, newJan)
	if err != nil {
		return model.ARInput{}, err
	}
	if existingMaster != nil {
		rec.Apname = existingMaster.MA018
		rec.Apkg = fmt.Sprintf("%s %g%s", existingMaster.MA037, existingMaster.MA044, tani.ResolveName(existingMaster.MA039))
		rec.Amaker = existingMaster.MA030
		rec.Ayjpu = existingMaster.MA044
		rec.Ajpu = existingMaster.MA133
		return rec, nil
	}

	masterInput := model.MaMasterInput{MA000: newJan, MA009: rec.Ayj, MA018: rec.Apname}
	if err := db.CreateMaMaster(conn, masterInput); err != nil {
		return model.ARInput{}, err
	}
	return rec, nil
}


----- C:\Dev\KARASHI\inventory\handler.go -----
// File: inventory/handler.go
package inventory

import (
	"database/sql"
	"encoding/json"
	"karashi/db"
	"karashi/model"
	"log"
	"net/http"
)

func UploadInventoryHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		if r.Method != http.MethodPost {
			http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
			return
		}
		file, _, err := r.FormFile("file")
		if err != nil {
			http.Error(w, "File upload error", http.StatusBadRequest)
			return
		}
		defer file.Close()

		parsedRecords, err := ParseInventory(file)
		if err != nil {
			http.Error(w, "Inventory CSV parse error", http.StatusInternalServerError)
			log.Printf("inventory.ParseInventory error: %v", err)
			return
		}

		var finalRecords []model.ARInput
		for _, rec := range parsedRecords {
			processedRec, err := ExecuteInventoryBranching(conn, rec)
			if err != nil {
				log.Printf("ExecuteInventoryBranching failed for JAN %s: %v", rec.Ajc, err)
				continue
			}
			finalRecords = append(finalRecords, processedRec)
		}

		// Save the processed data to the inventory and a_records tables
		if err := db.PersistInventoryRecords(conn, finalRecords); err != nil {
			log.Printf("PersistInventoryRecords error: %v", err)
			http.Error(w, "internal server error", http.StatusInternalServerError)
			return
		}
		if err := db.PersistARecords(conn, finalRecords); err != nil {
			log.Printf("PersistARecords error: %v", err)
			http.Error(w, "internal server error", http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		json.NewEncoder(w).Encode(map[string]interface{}{
			"message": "Processed and saved Inventory CSV successfully",
			"records": finalRecords,
		})
	}
}


----- C:\Dev\KARASHI\inventory\parser.go -----
// File: inventory/parser.go
package inventory

import (
	"encoding/csv"
	"fmt"
	"io"
	"karashi/model"
	"strconv"
	"strings"

	"golang.org/x/text/encoding/japanese"
	"golang.org/x/text/transform"
)

func ParseInventory(r io.Reader) ([]model.ARInput, error) {
	reader := csv.NewReader(transform.NewReader(r, japanese.ShiftJIS.NewDecoder()))
	reader.FieldsPerRecord = -1

	headerRow, err := reader.Read()
	if err != nil {
		return nil, fmt.Errorf("failed to read header row: %w", err)
	}
	date := ""
	if len(headerRow) > 4 {
		date = strings.Trim(headerRow[4], `"' `)
	}

	if _, err := reader.Read(); err != nil && err != io.EOF {
		// Skip second row
	}

	var records []model.ARInput
	for {
		row, err := reader.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			continue
		}
		if len(row) < 46 {
			continue
		}

		// 0-indexed columns
		janQtyStr := strings.Trim(row[21], `"' `)
		coeffStr := strings.Trim(row[17], `"' `)

		janQty, _ := strconv.ParseFloat(janQtyStr, 64)
		coeff, _ := strconv.ParseFloat(coeffStr, 64)

		yjQty := janQty * coeff // Calculate YJ Quantity

		rec := model.ARInput{
			Adate:      date,
			Aflag:      4, // vvv 「種別」に4をセット vvv
			Apname:     strings.Trim(row[12], `"' `),
			Ajanqty:    janQty,
			Ajpu:       coeff,
			Ajanunitnm: strings.Trim(row[23], `"' `),
			Ayjqty:     yjQty,
			Ayjunitnm:  strings.Trim(row[16], `"' `),
			Ayj:        strings.Trim(row[42], `"' `),
			Ajc:        strings.Trim(row[45], `"' `),
		}
		records = append(records, rec)
	}
	return records, nil
}


----- C:\Dev\KARASHI\loader\loader.go -----
// File: loader/loader.go
package loader

import (
	"database/sql"
	"encoding/csv"
	"fmt"
	"io"
	"os"
	"strconv"
	"strings"

	"golang.org/x/text/encoding/japanese"
	"golang.org/x/text/transform"
)

// 各テーブルのスキーマ情報（どの列が数値か）を定義します
var tableSchemas = map[string]map[int]string{
	"jcshms": {
		44: "real", // JC044
		61: "int",  // JC061
		62: "int",
		63: "int",
		64: "int",
		65: "int",
		66: "int",
	},
	"jancode": { // jancodeの定義を元に戻します
		7: "real", // JA006
		9: "real", // JA008
	},
}

func InitDatabase(db *sql.DB) error {
	if err := applySchema(db); err != nil {
		return fmt.Errorf("schema.sql 読み込み失敗: %w", err)
	}
	if err := loadCSV(db, "SOU/JCSHMS.CSV", "jcshms", 125, false); err != nil {
		return fmt.Errorf("JCSHMS 読み込み失敗: %w", err)
	}
	if err := loadCSV(db, "SOU/JANCODE.CSV", "jancode", 30, true); err != nil {
		return fmt.Errorf("JANCODE 読み込み失敗: %w", err)
	}
	return nil
}

func applySchema(db *sql.DB) error {
	schema, err := os.ReadFile("schema.sql")
	if err != nil {
		return err
	}
	_, err = db.Exec(string(schema))
	return err
}

func loadCSV(db *sql.DB, filepath, tablename string, columns int, skipHeader bool) error {
	f, err := os.Open(filepath)
	if err != nil {
		return err
	}
	defer f.Close()

	r := csv.NewReader(transform.NewReader(f, japanese.ShiftJIS.NewDecoder()))
	r.LazyQuotes = true
	r.FieldsPerRecord = -1
	if skipHeader {
		if _, err := r.Read(); err != nil && err != io.EOF {
			return err
		}
	}

	tx, err := db.Begin()
	if err != nil {
		return err
	}
	defer tx.Rollback()

	placeholders := make([]string, columns)
	for i := 0; i < columns; i++ {
		placeholders[i] = "?"
	}
	stmt, err := tx.Prepare(fmt.Sprintf(
		"INSERT OR REPLACE INTO %s VALUES (%s)",
		tablename, strings.Join(placeholders, ","),
	))
	if err != nil {
		return err
	}
	defer stmt.Close()

	schema := tableSchemas[tablename]

	for {
		row, err := r.Read()
		if err == io.EOF {
			break
		}
		if err != nil || len(row) < columns {
			continue
		}

		args := make([]interface{}, columns)
		for i, val := range row {
			if i >= columns {
				break
			}
			colType, isNumeric := schema[i+1]
			if isNumeric {
				switch colType {
				case "real":
					num, _ := strconv.ParseFloat(strings.TrimSpace(val), 64)
					args[i] = num
				case "int":
					num, _ := strconv.ParseInt(strings.TrimSpace(val), 10, 64)
					args[i] = num
				default:
					args[i] = val
				}
			} else {
				args[i] = val
			}
		}

		if _, err := stmt.Exec(args...); err != nil {
			continue
		}
	}
	return tx.Commit()
}


----- C:\Dev\KARASHI\model\types.go -----
// File: model/types.go
package model

// ARInputは、最終的にa_recordsテーブルに登録されるレコードの完全な構造体です。
type ARInput struct {
	Adate              string
	Apcode             string
	Arpnum             string
	Alnum              string
	Aflag              int
	Ajc                string
	Ayj                string
	Apname             string
	Akana              string
	Apkg               string
	Amaker             string
	Adatqty            float64
	Ajanqty            float64
	Ajpu               float64
	Ajanunitnm         string
	Ajanunitcode       string
	Ayjqty             float64
	Ayjpu              float64
	Ayjunitnm          string
	Aunitprice         float64
	Asubtotal          float64
	Ataxamt            float64
	Ataxrate           float64
	Aexpdate           float64
	Alot               string
	Adokuyaku          int
	Agekiyaku          int
	Amayaku            int
	Akouseisinyaku     int
	Akakuseizai        int
	Akakuseizaigenryou int
	Ama                string
}

// ParsedUsageは、USAGE CSVファイルの1行からパースされた生データです。
type ParsedUsage struct {
	Date       string
	Jc         string
	Yj         string
	Pname      string
	YjQty      float64
	YjUnitName string
}

// MaMasterは、ma_masterテーブルの1レコードの完全なデータです。
type MaMaster struct {
	MA000 string  // JAN or 合成JAN
	MA009 string  // YJコード
	MA018 string  // 品名
	MA022 string  // 品名かな
	MA030 string  // メーカー
	MA037 string  // 包装
	MA039 string  // YJ側単位名
	MA044 float64 // YJ側数量文字列
	MA061 int     // 毒薬フラグ
	MA062 int     // 劇薬フラグ
	MA063 int     // 麻薬フラグ
	MA064 int     // 向精神薬フラグ
	MA065 int     // 覚せい剤フラグ
	MA066 int     // 覚醒剤原料フラグ
	MA131 float64 //
	MA132 int     // JAN単位コード
	MA133 float64 // JANあたり数量
}

// MaMasterInputは、新しいma_masterレコードを作成するために必要なデータ構造です。
type MaMasterInput struct {
	// vvv ここから下が修正箇所 vvv
	MA000, MA009, MA018, MA022, MA030, MA037, MA039 string
	MA044, MA131, MA133                             float64
	MA061, MA062, MA063, MA064, MA065, MA066, MA132 int
}


----- C:\Dev\KARASHI\static\css\styles.css -----
/* File: static/css/styles.css */

/* リセット & 共通 */
body {
  margin: 0;
  font-family: sans-serif;
}

header nav {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  padding: 8px 20px;
  background: #fff;
  border-bottom: 1px solid #ccc;
  align-items: center;
}
header nav .btn {
  flex: 0 1 auto;
  padding: 6px 12px;
  font-size: 14px;
  cursor: pointer;
}
#printBtn {
  margin-left: auto;
}

#debug {
  background: #f0f0f0;
  padding: 0.5em;
  margin: 1em 20px;
  white-space: pre-wrap;
}

#outputTable {
  width: 100%;
  table-layout: fixed;
  border-collapse: collapse;
  margin: 0 auto 2em;
}
#outputTable th,
#outputTable td {
  border: 1px solid #ccc;
  padding: 4px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  font-size: 12px; /* ← ここで指定します */
}
#outputTable thead th {
  position: sticky;
  top: 0;
  background: #f0f0f0;
  z-index: 1;
  text-align: center;
}

/* 列幅（％） */
#outputTable colgroup col:nth-child(1) { width: 4.32%; } /* 91px */
#outputTable colgroup col:nth-child(2) { width: 2.13%; } /* 45px */
#outputTable colgroup col:nth-child(3) { width: 5.50%; } /* 116px */
#outputTable colgroup col:nth-child(4) { width: 5.88%; } /* 124px */
#outputTable colgroup col:nth-child(5) { width: 8.63%; } /* 182px */
#outputTable colgroup col:nth-child(6) { width: 4.74%; } /* 100px */
#outputTable colgroup col:nth-child(7) { width: 8.63%; } /* 182px */
#outputTable colgroup col:nth-child(8) { width: 2.13%; } /* 45px */
#outputTable colgroup col:nth-child(9) { width: 3.42%; } /* 72px */
#outputTable colgroup col:nth-child(10) { width: 4.74%; } /* 100px */
#outputTable colgroup col:nth-child(11) { width: 3.46%; } /* 73px */
#outputTable colgroup col:nth-child(12) { width: 2.80%; } /* 59px */
#outputTable colgroup col:nth-child(13) { width: 4.13%; } /* 87px */
#outputTable colgroup col:nth-child(14) { width: 3.46%; } /* 73px */
#outputTable colgroup col:nth-child(15) { width: 4.74%; } /* 100px */
#outputTable colgroup col:nth-child(16) { width: 4.74%; } /* 100px */
#outputTable colgroup col:nth-child(17) { width: 2.75%; } /* 58px */
#outputTable colgroup col:nth-child(18) { width: 2.13%; } /* 45px */
#outputTable colgroup col:nth-child(19) { width: 3.94%; } /* 83px */
#outputTable colgroup col:nth-child(20) { width: 4.74%; } /* 100px */
#outputTable colgroup col:nth-child(21) { width: 4.74%; } /* 100px */
#outputTable colgroup col:nth-child(22) { width: 4.74%; } /* 100px */
#outputTable colgroup col:nth-child(23) { width: 1.61%; } /* 34px */
#outputTable colgroup col:nth-child(24) { width: 1.80%; } /* 38px */

/* テキスト揃え */
#outputTable td:nth-child(8),
#outputTable td:nth-child(9),
#outputTable td:nth-child(10),
#outputTable td:nth-child(12),
#outputTable td:nth-child(13),
#outputTable td:nth-child(15),
#outputTable td:nth-child(16),
#outputTable td:nth-child(17),
#outputTable td:nth-child(18) { text-align: right; }

/* vvv 中央揃えの列番号を修正 vvv */
#outputTable td:nth-child(1),
#outputTable td:nth-child(2),
#outputTable td:nth-child(3),
#outputTable td:nth-child(4),
#outputTable td:nth-child(21),
#outputTable td:nth-child(23),
#outputTable td:nth-child(24) { text-align: center; }

/* vvv 左揃えの列番号を修正 vvv */
#outputTable td:nth-child(5),
#outputTable td:nth-child(6),
#outputTable td:nth-child(7),
#outputTable td:nth-child(11),
#outputTable td:nth-child(14),
#outputTable td:nth-child(19),
#outputTable td:nth-child(20),
#outputTable td:nth-child(22) { text-align: left; }

/* フィルタ：MAフラグ "1" or "2" の行のみ表示 */
#outputTable tbody tr { display: none; }
#outputTable tbody tr.modified { display: table-row; }

/* 印刷設定 */
@page {
  size: A4 landscape;
  margin: 10mm 10mm;
}
@media print {
  body * { visibility: hidden; }
  #outputTable,
  #outputTable * { visibility: visible; }
  #outputTable {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
  }
  #outputTable th,
  #outputTable td { font-size: 8px; }
}

----- C:\Dev\KARASHI\static\js\dat.js -----
// File: static/js/dat.js
document.addEventListener("DOMContentLoaded", () => {
  const btn = document.getElementById("datBtn");
  const input = document.getElementById("datInput");
  const debug = document.getElementById("debug");
  const table = document.getElementById("outputTable");
  const thead = table.querySelector("thead");
  const tbody = table.querySelector("tbody");

  btn.addEventListener("click", () => {
    input.value = null;
    input.click();
  });

  input.addEventListener("change", async () => {
    if (!input.files.length) return;
    debug.textContent = `${input.files.length}件のDATファイルをアップロード中…`;

    let allRecords = [];
    for (const file of input.files) {
      const form = new FormData();
      form.append("file", file);

      try {
        const res = await fetch("/uploadDat", { method: "POST", body: form });
        if (!res.ok) {
          console.error(`Error uploading ${file.name}: ${res.status}`);
          continue;
        }

        const data = await res.json();
        if (Array.isArray(data.records)) {
          allRecords.push(...data.records);
        }
      } catch (err) {
        console.error(`Error processing ${file.name}:`, err);
        continue;
      }
    }

    debug.textContent = `合計処理件数: ${allRecords.length}`;
    
    thead.innerHTML = `
      <tr>
        <th>日付</th><th>種別</th><th>YJ</th><th>JAN</th><th>製品名</th>
        <th>包装</th><th>メーカー</th><th class="num">個数</th>
        <th class="num">JAN数量</th><th class="num">JAN包装数量</th><th>JAN単位</th>
        <th class="num">YJ数量</th><th class="num">YJ包装数量</th><th>YJ単位</th>
        <th class="num">単価</th><th class="num">金額</th><th class="num">税額</th>
        <th class="num">税率</th><th>期限</th><th>ロット</th><th>得意先</th>
        <th>伝票番号</th><th class="num">行</th><th>MA</th>
      </tr>`;
    tbody.innerHTML = "";

    allRecords.forEach(rec => {
      const tr = document.createElement("tr");
      tr.classList.add("modified");
      tr.innerHTML = `
        <td>${rec.Adate || ""}</td>
        <td>${rec.Aflag || ""}</td>
        <td>${rec.Ayj || ""}</td>
        <td>${rec.Ajc || ""}</td>
        <td>${rec.Apname || ""}</td>
        <td>${rec.Apkg || ""}</td>
        <td>${rec.Amaker || ""}</td>
        <td class="num">${rec.Adatqty || ""}</td>
        <td class="num">${rec.Ajanqty || ""}</td>
        <td class="num">${rec.Ajpu || ""}</td>
        <td>${rec.Ajanunitnm || ""}</td>
        <td class="num">${rec.Ayjqty || ""}</td>
        <td class="num">${rec.Ayjpu || ""}</td>
        <td>${rec.Ayjunitnm || ""}</td>
        <td class="num">${rec.Aunitprice || ""}</td>
        <td class="num">${rec.Asubtotal || ""}</td>
        <td class="num">${rec.Ataxamount || ""}</td>
        <td class="num">${rec.Ataxrate || ""}</td>
        <td>${rec.Aexpdate || ""}</td>
        <td>${rec.Alot || ""}</td>
        <td>${rec.Apcode || ""}</td>
        <td>${rec.Arpnum || ""}</td>
        <td class="num">${rec.Alnum || ""}</td>
        <td>${String(rec.Ama).trim() || ""}</td>
      `;
      tbody.appendChild(tr);
    });
  });
});

----- C:\Dev\KARASHI\static\js\inventory.js -----
// File: static/js/inventory.js
document.addEventListener("DOMContentLoaded", () => {
  const btn = document.getElementById("inventoryBtn");
  const input = document.getElementById("inventoryInput");
  const debug = document.getElementById("debug");
  const table = document.getElementById("outputTable");
  const thead = table.querySelector("thead");
  const tbody = table.querySelector("tbody");

  btn.addEventListener("click", () => {
    input.value = null;
    input.click();
  });

  input.addEventListener("change", async () => {
    if (!input.files.length) return;
    debug.textContent = "棚卸CSVファイルをアップロード中…";

    const form = new FormData();
    form.append("file", input.files[0]);

    try {
      const res = await fetch("/uploadInventory", { method: "POST", body: form });
      if (!res.ok) {
        debug.textContent = `アップロード失敗: ${res.status}`;
        return;
      }

      const data = await res.json();
      const records = Array.isArray(data.records) ? data.records : [];
      debug.textContent = `処理件数: ${records.length}`;
      
      // Restore the full 24-column header
      thead.innerHTML = `
        <tr>
          <th>日付</th><th>種別</th><th>YJ</th><th>JAN</th><th>製品名</th>
          <th>包装</th><th>メーカー</th><th class="num">個数</th>
          <th class="num">JAN数量</th><th class="num">JAN包装数量</th><th>JAN単位</th>
          <th class="num">YJ数量</th><th class="num">YJ包装数量</th><th>YJ単位</th>
          <th class="num">単価</th><th class="num">金額</th><th class="num">税額</th>
          <th class="num">税率</th><th>期限</th><th>ロット</th><th>得意先</th>
          <th>伝票番号</th><th class="num">行</th><th>MA</th>
        </tr>`;
      tbody.innerHTML = "";

      // Render data into the full 24-column layout
records.forEach(rec => {
        const tr = document.createElement("tr");
        tr.classList.add("modified");
        tr.innerHTML = `
          <td>${rec.Adate || ""}</td>
          <td>${rec.Aflag || ""}</td>
          <td>${rec.Ayj || ""}</td>
          <td>${rec.Ajc || ""}</td>
          <td>${rec.Apname || ""}</td>
          <td>${rec.Apkg || ""}</td>
          <td>${rec.Amaker || ""}</td>
          <td class="num">${rec.Adatqty != null ? rec.Adatqty : ""}</td>
          <td class="num">${rec.Ajanqty != null ? rec.Ajanqty : "0"}</td>
          <td class="num">${rec.Ajpu != null ? rec.Ajpu : ""}</td>
          <td>${rec.Ajanunitnm || ""}</td>
          <td class="num">${rec.Ayjqty != null ? rec.Ayjqty : "0"}</td>
          <td class="num">${rec.Ayjpu != null ? rec.Ayjpu : ""}</td>
          <td>${rec.Ayjunitnm || ""}</td>
          <td class="num">${rec.Aunitprice != null ? rec.Aunitprice : ""}</td>
          <td class="num">${rec.Asubtotal != null ? rec.Asubtotal : ""}</td>
          <td class="num">${rec.Ataxamount != null ? rec.Ataxamount : ""}</td>
          <td class="num">${rec.Ataxrate || ""}</td>
          <td>${rec.Aexpdate || ""}</td>
          <td>${rec.Alot || ""}</td>
          <td>${rec.Apcode || ""}</td>
          <td>${rec.Arpnum || ""}</td>
          <td class="num">${rec.Alnum || ""}</td>
          <td>${String(rec.Ama).trim() || ""}</td>
        `;
        tbody.appendChild(tr);
      });

    } catch (err) {
      console.error(err);
      debug.textContent = "棚卸アップロードエラー: " + err.message;
    }
  });
});

----- C:\Dev\KARASHI\static\js\usage.js -----
// File: static/js/usage.js

document.addEventListener("DOMContentLoaded", () => {
  const btn = document.getElementById("usageBtn");
  const input = document.getElementById("usageInput");
  const debug = document.getElementById("debug");
  const table = document.getElementById("outputTable");
  const thead = table.querySelector("thead");
  const tbody = table.querySelector("tbody");

  // USAGE ボタン押下でテーブル初期化＆ファイル選択ダイアログ
  btn.addEventListener("click", () => {
    debug.textContent = "";
    // vvv ヘッダーに「JAN員数」「YJ員数」を追加 vvv
    thead.innerHTML = `
  <tr>
    <th>日付</th><th>種別</th><th>YJ</th><th>JAN</th><th>製品名</th>
    <th>包装</th><th>メーカー</th><th class="num">個数</th>
    <th class="num">JAN数量</th><th class="num">JAN包装数量</th><th>JAN単位</th>
    <th class="num">YJ数量</th><th class="num">YJ包装数量</th><th>YJ単位</th>
    <th class="num">単価</th><th class="num">金額</th><th class="num">税額</th>
    <th class="num">税率</th><th>期限</th><th>ロット</th><th>得意先</th>
    <th>伝票番号</th><th class="num">行</th><th>MA</th>
  </tr>`;
    // ^^^ ここまで ^^^
    tbody.innerHTML = "";
    input.value = null;
    input.click();
  });

  // ファイル選択 → サーバへアップロード → JSONで受信 → テーブル描画
  input.addEventListener("change", async () => {
    if (!input.files.length) return;
    debug.textContent = "USAGEファイルアップロード中…";

    const form = new FormData();
    for (const file of input.files) {
      form.append("file", file);
    }

    try {
      const res = await fetch("/uploadUsage", {
        method: "POST",
        body: form
      });
      if (!res.ok) {
        debug.textContent = `アップロード失敗: ${res.status}`;
        return;
      }

      const data = await res.json();
      const records = Array.isArray(data.records) ? data.records : [];
      
      debug.textContent = `受信件数: ${records.length}`;

      tbody.innerHTML = "";
      records
        .filter(r => ["1","2","3","4","5","6"].includes(String(r.Ama).trim()))
        .forEach(rec => {
          const tr = document.createElement("tr");
          tr.classList.add("modified");
          // vvv データ行に rec.Ajpu と rec.Ayjpu を追加 vvv
          tr.innerHTML = `
            <td>${rec.Adate || ""}</td>
            <td>${rec.Aflag || ""}</td>
            <td>${rec.Ayj   || ""}</td>
            <td>${rec.Ajc   || ""}</td>
            <td>${rec.Apname|| ""}</td>
            <td>${rec.Apkg  || ""}</td>
            <td>${rec.Amaker|| ""}</td>
            <td class="num">${rec.Adatqty      || ""}</td>
            <td class="num">${rec.Ajanqty      || ""}</td>
            <td class="num">${rec.Ajpu         || ""}</td>
            <td>${rec.Ajanunitnm   || ""}</td>
            <td class="num">${rec.Ayjqty       || ""}</td>
            <td class="num">${rec.Ayjpu        || ""}</td>
            <td>${rec.Ayjunitnm    || ""}</td>
            <td class="num">${rec.Aunitprice   || ""}</td>
            <td class="num">${rec.Asubtotal    || ""}</td>
            <td class="num">${rec.Ataxamount   || ""}</td>
            <td class="num">${rec.Ataxrate     || ""}</td>
            <td>${rec.Aexpdate        || ""}</td>
            <td>${rec.Alot            || ""}</td>
            <td>${rec.Apcode          || ""}</td>
            <td>${rec.Arpnum          || ""}</td>
            <td class="num">${rec.Alnum      || ""}</td>
            <td>${String(rec.Ama).trim()       || ""}</td>
          `;
          // ^^^ ここまで ^^^
          tbody.appendChild(tr);
        });
    } catch (err) {
      console.error(err);
      debug.textContent = "アップロードエラー: " + err.message;
    }
  });
});

----- C:\Dev\KARASHI\static\index.html -----
<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>YAMATO 集計システム</title>
  <link rel="stylesheet" href="/static/css/styles.css" />
  <link rel="icon" href="/favicon.ico" type="image/x-icon" />
  <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
</head>
<body>
  <header id="header">
    <nav>
      <button id="datBtn" class="btn">納品・返品</button>
      <button id="usageBtn" class="btn">USAGE</button>
      <button id="aggregateBtn" class="btn">集計</button>
      <button id="inventoryBtn" class="btn">棚卸</button>
      <button id="ma2Btn" class="btn">MA2編集</button>
      <button id="inoutBtn" class="btn">出庫・入庫</button>
      <button id="printBtn" class="btn">印刷</button>
    </nav>
  </header>

  <input type="file" id="datInput" multiple style="display:none" />
  <input type="file" id="usageInput" multiple style="display:none" />
  <input type="file" id="inventoryInput" style="display:none" />
  <pre id="debug"></pre>

  <table id="outputTable">
    <colgroup>
      <col><col><col><col><col><col><col><col><col><col>
      <col><col><col><col><col><col><col><col><col><col>
      <col><col><col><col>
    </colgroup>
<thead>
  <tr>
    <th>日付</th><th>種別</th><th>YJ</th><th>JAN</th><th>製品名</th>
    <th>包装</th><th>メーカー</th><th class="num">個数</th>
    <th class="num">JAN数量</th><th class="num">JAN包装数量</th><th>JAN単位</th>
    <th class="num">YJ数量</th><th class="num">YJ包装数量</th><th>YJ単位</th>
    <th class="num">単価</th><th class="num">金額</th><th class="num">税額</th>
    <th class="num">税率</th><th>期限</th><th>ロット</th><th>得意先</th>
    <th>伝票番号</th><th class="num">行</th><th>MA</th>
  </tr>
</thead>
    <tbody>
      </tbody>
  </table>

  <script src="/static/js/dat.js"></script>
  <script src="/static/js/usage.js"></script>
  <script src="/static/js/inventory.js"></script>
  <script>
    // 印刷ボタン動作
    document.getElementById("printBtn")
      .addEventListener("click", () => window.print());
  </script>
</body>
</html>

----- C:\Dev\KARASHI\tani\tani.go -----
// File: tani/tani.go
package tani

import (
	"encoding/csv"
	"fmt"
	"io"
	"os"

	"golang.org/x/text/encoding/japanese"
	"golang.org/x/text/transform"
)

// internalMap にコード→名称を保持します
var internalMap map[string]string

// ★ 新規追加: 名称→コードの逆引きマップ
var reverseMap map[string]string

// LoadTANIFile は ShiftJIS で保存された単位マスターCSVを読み込みます。
func LoadTANIFile(path string) (map[string]string, error) {
	file, err := os.Open(path)
	if err != nil {
		return nil, fmt.Errorf("LoadTANIFile: open %s: %w", path, err)
	}
	defer file.Close()

	decoder := japanese.ShiftJIS.NewDecoder()
	reader := csv.NewReader(transform.NewReader(file, decoder))
	reader.LazyQuotes = true
	reader.FieldsPerRecord = -1

	m := make(map[string]string)
	for {
		record, err := reader.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			return nil, fmt.Errorf("LoadTANIFile: read %s: %w", path, err)
		}
		if len(record) < 2 {
			continue
		}
		code := record[0]
		name := record[1]
		m[code] = name
	}
	internalMap = m

	// ★ 新規追加: 読み込み時に逆引きマップも生成する
	reverseMap = make(map[string]string)
	for code, name := range internalMap {
		reverseMap[name] = code
	}

	return m, nil
}

// ResolveName は与えられたコードの名称を返します。
func ResolveName(code string) string {
	if internalMap == nil {
		return code
	}
	if name, ok := internalMap[code]; ok {
		return name
	}
	return code
}

// ★ 新規追加: 単位名をコードに変換する関数
func ResolveCode(name string) string {
	if reverseMap == nil {
		return "" // マップがなければ空文字を返す
	}
	if code, ok := reverseMap[name]; ok {
		return code
	}
	return "" // 見つからなければ空文字を返す
}


----- C:\Dev\KARASHI\usage\branch.go -----
// File: usage/branch.go
package usage

import (
	"database/sql"
	"fmt"
	"karashi/db"
	"karashi/model"
	"karashi/tani"
	"strconv"
)

// ExecuteBranching determines which logic branch to follow based on the parsed USAGE data.
func ExecuteBranching(conn *sql.DB, pu model.ParsedUsage) (model.ARInput, error) {
	key := pu.Jc
	isSyntheticKey := false
	if key == "" {
		key = fmt.Sprintf("9999999999999%s", pu.Pname)
		isSyntheticKey = true
	}

	master, err := db.GetMaMasterByCode(conn, key)
	if err != nil {
		return model.ARInput{}, fmt.Errorf("failed to get ma_master by key %s: %w", key, err)
	}

	if master != nil {
		return processBranch1(pu, master)
	}

	if isSyntheticKey {
		return processBranch2(conn, pu)
	}

	jcshms, err := db.GetJcshmsByJan(conn, pu.Jc)
	if err != nil {
		return model.ARInput{}, fmt.Errorf("failed to get jcshms by jan %s: %w", pu.Jc, err)
	}

	if jcshms != nil {
		if jcshms.JC009 != "" {
			return processBranch5(conn, pu, jcshms)
		} else {
			return processBranch4(conn, pu, jcshms)
		}
	} else {
		return processBranch6(conn, pu)
	}
}

// --- Helper Functions for Each Branch ---

// processBranch1: Use an existing ma_master record.
func processBranch1(pu model.ParsedUsage, master *model.MaMaster) (model.ARInput, error) {
	ayjunitnm := tani.ResolveName(master.MA039)
	ajanunitcode := strconv.Itoa(master.MA132)
	var ajanunitnm string
	if ajanunitcode == "0" {
		ajanunitnm = ayjunitnm
	} else {
		ajanunitnm = tani.ResolveName(ajanunitcode)
	}

	pkg := fmt.Sprintf("%s %g%s", master.MA037, master.MA044, ayjunitnm)
	if master.MA131 != 0 && master.MA133 != 0 {
		pkg += fmt.Sprintf(" (%g%s×%g%s)", master.MA131, ayjunitnm, master.MA133, ajanunitnm)
	}

	// vvv ここが修正箇所 vvv
	janQty := 0.0
	if master.MA131 != 0 { // MA133 から MA131 に変更
		janQty = pu.YjQty / master.MA131
	}
	// ^^^ ここまで ^^^

	return model.ARInput{
		Adate:              pu.Date,
		Aflag:              BranchAflag,
		Ajc:                master.MA000,
		Ayj:                master.MA009,
		Apname:             master.MA018,
		Akana:              master.MA022,
		Apkg:               pkg,
		Amaker:             master.MA030,
		Ajanqty:            janQty,
		Ajpu:               master.MA133,
		Ajanunitnm:         ajanunitnm,
		Ajanunitcode:       ajanunitcode,
		Ayjqty:             pu.YjQty,
		Ayjpu:              master.MA044,
		Ayjunitnm:          ayjunitnm,
		Adokuyaku:          master.MA061,
		Agekiyaku:          master.MA062,
		Amayaku:            master.MA063,
		Akouseisinyaku:     master.MA064,
		Akakuseizai:        master.MA065,
		Akakuseizaigenryou: master.MA066,
		Ama:                Ama1,
	}, nil
}

// processBranch2: Register a new item that has no JAN code.
func processBranch2(conn *sql.DB, pu model.ParsedUsage) (model.ARInput, error) {
	newYjCode, err := db.NextSequence(conn, "MA2Y")
	if err != nil {
		return model.ARInput{}, err
	}
	syntheticJan := fmt.Sprintf("9999999999999%s", pu.Pname)

	masterInput := model.MaMasterInput{
		MA000: syntheticJan,
		MA009: newYjCode,
		MA018: pu.Pname,
		MA039: tani.ResolveCode(pu.YjUnitName),
	}
	if err := db.CreateMaMaster(conn, masterInput); err != nil {
		return model.ARInput{}, err
	}

	return model.ARInput{
		Adate:     pu.Date,
		Aflag:     BranchAflag,
		Ajc:       syntheticJan,
		Ayj:       newYjCode,
		Apname:    pu.Pname,
		Ayjqty:    pu.YjQty,
		Ayjunitnm: pu.YjUnitName,
		Ama:       Ama2,
	}, nil
}

// processBranch4: Create a new ma_master record based on JCSHMS data and assign a new YJ code.
func processBranch4(conn *sql.DB, pu model.ParsedUsage, jcshms *db.JCShms) (model.ARInput, error) {
	newYjCode, err := db.NextSequence(conn, "MA2Y")
	if err != nil {
		return model.ARInput{}, err
	}
	if err := createMasterFromJcshms(conn, pu.Jc, newYjCode, jcshms); err != nil {
		return model.ARInput{}, err
	}
	return createARInputFromJcshms(pu, newYjCode, jcshms, Ama4)
}

// processBranch5: Create a new ma_master record based on JCSHMS data using the existing YJ code.
func processBranch5(conn *sql.DB, pu model.ParsedUsage, jcshms *db.JCShms) (model.ARInput, error) {
	if err := createMasterFromJcshms(conn, pu.Jc, jcshms.JC009, jcshms); err != nil {
		return model.ARInput{}, err
	}
	return createARInputFromJcshms(pu, jcshms.JC009, jcshms, Ama5)
}

// processBranch6: Register a new item based only on its JAN code.
func processBranch6(conn *sql.DB, pu model.ParsedUsage) (model.ARInput, error) {
	newYjCode, err := db.NextSequence(conn, "MA2Y")
	if err != nil {
		return model.ARInput{}, err
	}

	masterInput := model.MaMasterInput{
		MA000: pu.Jc,
		MA009: newYjCode,
		MA018: pu.Pname,
		MA039: tani.ResolveCode(pu.YjUnitName),
	}
	if err := db.CreateMaMaster(conn, masterInput); err != nil {
		return model.ARInput{}, err
	}

	return model.ARInput{
		Adate:     pu.Date,
		Aflag:     BranchAflag,
		Ajc:       pu.Jc,
		Ayj:       newYjCode,
		Apname:    pu.Pname,
		Ayjqty:    pu.YjQty,
		Ayjunitnm: pu.YjUnitName,
		Ama:       Ama6,
	}, nil
}

// --- Common Helpers for Branches 4 & 5 ---

// createMasterFromJcshms creates a MaMasterInput struct from JCSHMS data and saves it.
func createMasterFromJcshms(conn *sql.DB, jan, yj string, jcshms *db.JCShms) error {
	masterInput := model.MaMasterInput{
		MA000: jan,
		MA009: yj,
		MA018: jcshms.JC018,
		MA022: jcshms.JC022,
		MA030: jcshms.JC030,
		MA037: jcshms.JC037,
		MA039: jcshms.JC039,
		MA044: jcshms.JC044,
		MA061: jcshms.JC061,
		MA062: jcshms.JC062,
		MA063: jcshms.JC063,
		MA064: jcshms.JC064,
		MA065: jcshms.JC065,
		MA066: jcshms.JC066,
		MA131: jcshms.JA006.Float64,
		MA133: jcshms.JA008.Float64,
	}

	if jcshms.JA007.Valid {
		if val, err := strconv.Atoi(jcshms.JA007.String); err == nil {
			masterInput.MA132 = val
		}
	}

	return db.CreateMaMaster(conn, masterInput)
}

// createARInputFromJcshms creates the final ARInput record from JCSHMS data.
func createARInputFromJcshms(pu model.ParsedUsage, yj string, jcshms *db.JCShms, ama string) (model.ARInput, error) {
	ja006 := jcshms.JA006.Float64
	ja007Str := jcshms.JA007.String
	ja008 := jcshms.JA008.Float64

	ayjunitnm := tani.ResolveName(jcshms.JC039)
	var ajanunitnm string
	if ja007Str == "0" || ja007Str == "" {
		ajanunitnm = ayjunitnm
	} else {
		ajanunitnm = tani.ResolveName(ja007Str)
	}

	pkg := fmt.Sprintf("%s %g%s", jcshms.JC037, jcshms.JC044, ayjunitnm)
	if ja006 != 0 && ja008 != 0 {
		pkg += fmt.Sprintf(" (%g%s×%g%s)", ja006, ayjunitnm, ja008, ajanunitnm)
	}

	// ここの計算式はJA006を使うので正しいままです
	janQty := 0.0
	if jcshms.JA006.Valid && ja006 != 0 {
		janQty = pu.YjQty / ja006
	}

	return model.ARInput{
		Adate:              pu.Date,
		Aflag:              BranchAflag,
		Ajc:                pu.Jc,
		Ayj:                yj,
		Apname:             jcshms.JC018,
		Akana:              jcshms.JC022,
		Apkg:               pkg,
		Amaker:             jcshms.JC030,
		Ajanqty:            janQty,
		Ajpu:               ja008,
		Ajanunitnm:         ajanunitnm,
		Ajanunitcode:       ja007Str,
		Ayjqty:             pu.YjQty,
		Ayjpu:              jcshms.JC044,
		Ayjunitnm:          ayjunitnm,
		Adokuyaku:          jcshms.JC061,
		Agekiyaku:          jcshms.JC062,
		Amayaku:            jcshms.JC063,
		Akouseisinyaku:     jcshms.JC064,
		Akakuseizai:        jcshms.JC065,
		Akakuseizaigenryou: jcshms.JC066,
		Ama:                ama,
	}, nil
}


----- C:\Dev\KARASHI\usage\pausage.go -----
// File: usage/pausage.go
package usage

import (
	"encoding/csv"
	"fmt"
	"io"
	"karashi/model" // Import the new model package
	"strconv"

	"golang.org/x/text/encoding/japanese"
	"golang.org/x/text/transform"
)

// ParseUsage parses the USAGE CSV file.
func ParseUsage(r io.Reader) ([]model.ParsedUsage, error) {
	reader := csv.NewReader(transform.NewReader(r, japanese.ShiftJIS.NewDecoder()))
	reader.FieldsPerRecord = -1

	var out []model.ParsedUsage
	for {
		rec, err := reader.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			return nil, fmt.Errorf("csv read error: %w", err)
		}

		qty, _ := strconv.ParseFloat(rec[4], 64)

		out = append(out, model.ParsedUsage{
			Date:       rec[0],
			Yj:         rec[1],
			Jc:         rec[2],
			Pname:      rec[3],
			YjQty:      qty,
			YjUnitName: rec[5],
		})
	}
	return out, nil
}


----- C:\Dev\KARASHI\usage\types.go -----
// File: usage/types.go
package usage

// 構造体の定義はすべてmodel/types.goに移動しました。

// usageワークフローに特化した定数はここに残します。
const (
	BranchAflag = 3
)

// 分岐番号の定義
const (
	Ama1 = "1"
	Ama2 = "2"
	Ama3 = "3"
	Ama4 = "4"
	Ama5 = "5"
	Ama6 = "6"
)


----- C:\Dev\KARASHI\usage\upusage.go -----
// File: usage/upusage.go
package usage

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"karashi/db"
	"karashi/model"
	"log"
	"net/http"
)

func UploadUsageHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// --- 1. ファイルパース ---
		if r.Method != http.MethodPost {
			http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
			return
		}
		if err := r.ParseMultipartForm(32 << 20); err != nil {
			http.Error(w, fmt.Sprintf("parse form error: %v", err), http.StatusBadRequest)
			return
		}
		defer r.MultipartForm.RemoveAll()

		var allParsed []model.ParsedUsage
		files := r.MultipartForm.File["file"]
		if len(files) == 0 {
			w.Header().Set("Content-Type", "application/json; charset=utf-8")
			json.NewEncoder(w).Encode(map[string]interface{}{"records": []model.ARInput{}})
			return
		}

		for _, fh := range files {
			f, err := fh.Open()
			if err != nil {
				log.Printf("open file error: %v", err)
				continue
			}
			defer f.Close()

			recs, err := ParseUsage(f)
			if err != nil {
				log.Printf("parse error: %v", err)
				continue
			}
			allParsed = append(allParsed, recs...)
		}

		// --- 2. 前処理 (重複フィルタ) ---
		filtered := RemoveDuplicates(allParsed)

		// --- 3. 分岐処理 ---
		var finalARs []model.ARInput
		for _, pu := range filtered {
			// ★★★ ここが修正点 ★★★
			// 不要になった行番号の引数 'i' を削除
			ar, err := ExecuteBranching(conn, pu)
			if err != nil {
				log.Printf("ExecuteBranching failed for JAN %q: %v", pu.Jc, err)
				continue
			}
			finalARs = append(finalARs, ar)
		}

		// --- 4. データベースへの一括保存 ---
		if len(finalARs) > 0 {
			if err := db.PersistARecords(conn, finalARs); err != nil {
				log.Printf("PersistARecords error: %v", err)
				http.Error(w, "internal server error", http.StatusInternalServerError)
				return
			}
		}

		// --- 5. JSONレスポンス ---
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		response := map[string]interface{}{
			"records": finalARs,
		}
		if err := json.NewEncoder(w).Encode(response); err != nil {
			log.Printf("json encode error: %v", err)
		}
	}
}

// RemoveDuplicatesは重複排除のみを行います。
func RemoveDuplicates(rs []model.ParsedUsage) []model.ParsedUsage {
	seen := make(map[string]struct{}, len(rs))
	var out []model.ParsedUsage
	for _, r := range rs {
		key := fmt.Sprintf("%s|%s|%s|%s", r.Date, r.Jc, r.Yj, r.Pname)
		if _, ok := seen[key]; ok {
			continue
		}
		seen[key] = struct{}{}
		out = append(out, r)
	}
	return out
}


----- C:\Dev\KARASHI\main.go -----
// File: main.go
package main

import (
	"context"
	"database/sql"
	"flag"
	"log"
	"net/http"
	"os"
	"os/exec"
	"os/signal"
	"runtime"
	"syscall"
	"time"

	_ "github.com/mattn/go-sqlite3"

	"karashi/dat" // datパッケージをインポート
	"karashi/inventory"
	"karashi/loader"
	"karashi/tani"
	"karashi/usage"
)

func main() {
	// コマンドラインフラグを定義
	port := flag.String("port", "8080", "HTTP port")
	dbPath := flag.String("db", "yamato.db", "SQLite file path")
	flag.Parse()

	// データベース接続
	db, err := sql.Open("sqlite3", *dbPath)
	if err != nil {
		log.Fatalf("DB open failed: %v", err)
	}
	defer db.Close()

	// スキーマ適用とマスターデータのロードをまとめて実行
	if err := loader.InitDatabase(db); err != nil {
		log.Fatalf("master init failed: %v", err)
	}

	// 単位マスターの読み込み
	if _, err := tani.LoadTANIFile("SOU/TANI.CSV"); err != nil {
		log.Fatalf("tani load failed: %v", err)
	}

	// HTTPハンドラを登録
	mux := http.NewServeMux()
	mux.Handle("/uploadUsage", usage.UploadUsageHandler(db))
	mux.Handle("/uploadDat", dat.UploadDatHandler(db))                   // ← この行を追加
	mux.Handle("/uploadInventory", inventory.UploadInventoryHandler(db)) // ← この行を追加
	mux.Handle("/static/", http.StripPrefix("/static/", http.FileServer(http.Dir("./static"))))
	mux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		http.ServeFile(w, r, "./static/index.html")
	})

	// サーバーを起動
	srv := &http.Server{
		Addr:         ":" + *port,
		Handler:      loggingMiddleware(mux),
		ReadTimeout:  10 * time.Second,
		WriteTimeout: 10 * time.Second,
		IdleTimeout:  60 * time.Second,
	}

	go func() {
		log.Printf("→ starting on :%s", *port)
		openBrowser("http://localhost:" + *port)
		if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			log.Fatalf("listen error: %v", err)
		}
	}()

	// グレースフルシャットダウン処理
	stop := make(chan os.Signal, 1)
	signal.Notify(stop, os.Interrupt, syscall.SIGTERM)
	<-stop
	log.Println("⏳ shutting down…")

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	if err := srv.Shutdown(ctx); err != nil {
		log.Fatalf("shutdown failed: %v", err)
	}
	log.Println("✅ server stopped")
}

// openBrowser は、OSに応じてブラウザを開くヘルパー関数です。
func openBrowser(url string) {
	var cmd *exec.Cmd
	switch runtime.GOOS {
	case "windows":
		cmd = exec.Command("rundll32", "url.dll,FileProtocolHandler", url)
	case "darwin":
		cmd = exec.Command("open", url)
	default: // linux
		cmd = exec.Command("xdg-open", url)
	}
	_ = cmd.Start()
}

// loggingMiddleware は、リクエストのログを出力するミドルウェアです。
func loggingMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		start := time.Now()
		next.ServeHTTP(w, r)
		log.Printf("%s %s %s", r.Method, r.URL.Path, time.Since(start))
	})
}


----- C:\Dev\KARASHI\schema.sql -----
CREATE TABLE IF NOT EXISTS code_sequences (
  name    TEXT PRIMARY KEY,
  last_no INTEGER NOT NULL
);
INSERT OR IGNORE INTO code_sequences(name,last_no) VALUES ('MA2Y',0);




CREATE TABLE IF NOT EXISTS ma_master (
  MA000   TEXT    PRIMARY KEY,
  MA009   TEXT    NOT NULL DEFAULT '',      -- 発番済 YJ コード
  MA018   TEXT    NOT NULL DEFAULT '',      -- 品名
  MA022   TEXT    NOT NULL DEFAULT '',      -- 品名かな
  MA030   TEXT    NOT NULL DEFAULT '',      -- メーカー
  MA037   TEXT    NOT NULL DEFAULT '',      -- 包装
  MA039   TEXT    NOT NULL DEFAULT '',      -- YJ側単位コード
  -- vvv ここから下が修正箇所 vvv
  MA044   REAL    NOT NULL DEFAULT 0,        -- YJ側数量 (TEXT→REAL)
  MA061   INTEGER NOT NULL DEFAULT 0,        -- 毒薬
  MA062   INTEGER NOT NULL DEFAULT 0,        -- 劇薬
  MA063   INTEGER NOT NULL DEFAULT 0,        -- 麻薬
  MA064   INTEGER NOT NULL DEFAULT 0,        -- 向精神薬
  MA065   INTEGER NOT NULL DEFAULT 0,        -- 覚せい剤
  MA066   INTEGER NOT NULL DEFAULT 0,        -- 覚醒剤原料
  MA131   REAL    NOT NULL DEFAULT 0,        -- JANあたり数量1 (TEXT→REAL)
  MA132   INTEGER NOT NULL DEFAULT 0,        -- JAN単位コード (TEXT→INTEGER)
  MA133   REAL    NOT NULL DEFAULT 0         -- JANあたり数量2 (TEXT→REAL)
);





CREATE INDEX IF NOT EXISTS idxMaMasterMA009
  ON ma_master(MA009);



CREATE INDEX IF NOT EXISTS idx_master_MA009
  ON ma_master(MA009);

CREATE TABLE IF NOT EXISTS a_records (
  adate                      TEXT,
  apcode                     TEXT,
  arpnum                     TEXT,
  alnum                      TEXT,
  aflag                      INTEGER,
  ajc                        TEXT,
  ayj                        TEXT,
  apname                     TEXT,
  akana                      TEXT,
  apkg                       TEXT,
  amaker                     TEXT,
  adatqty                    REAL,
  ajanqty                    REAL,
  ajpu                       REAL,
  ajanunitname               TEXT,
  ajanunitcode               TEXT,
  ayjqty                     REAL,
  ayjpu                      TEXT,
  ayjunitname                TEXT,
  aunitprice                 REAL,
  asubtotal                  REAL,
  ataxamount                 REAL,
  ataxrate                   REAL,
  aexpdate                   REAL,
  alot                       TEXT,
  adokuyaku                  INTEGER DEFAULT 0,
  agekiyaku                  INTEGER DEFAULT 0,
  amayaku                    INTEGER DEFAULT 0,
  akouseisinyaku             INTEGER DEFAULT 0,
  akakuseizai                INTEGER DEFAULT 0,
  akakuseizaigenryou         INTEGER DEFAULT 0,
  ama                        TEXT,
  -- vvv ここから下が主キーの定義 vvv
  PRIMARY KEY(adate, apcode, arpnum, alnum, aflag, ajc, ayj)
  -- ^^^ ここまでが主キーの定義 ^^^
);

-- =========================================
-- 棚卸 (Inventory) テーブル定義
-- =========================================
CREATE TABLE IF NOT EXISTS inventory (
  inv_date         TEXT    NOT NULL,
  inv_jan_code     TEXT    NOT NULL,
  inv_yj_code      TEXT,
  inv_product_name TEXT,
  inv_quantity     REAL    NOT NULL,
  PRIMARY KEY (inv_date, inv_jan_code)
);

-- ソート／フィルタ用インデックス
CREATE INDEX IF NOT EXISTS idx_ar_apname_kana
  ON a_records(akana);
CREATE INDEX IF NOT EXISTS idx_ar_adokuyaku
  ON a_records(adokuyaku);
-- 必要に応じて他フラグにも INDEX を貼る

CREATE TABLE IF NOT EXISTS jcshms (
JC000 TEXT,
JC001 TEXT,
JC002 TEXT,
JC003 TEXT,
JC004 TEXT,
JC005 TEXT,
JC006 TEXT,
JC007 TEXT,
JC008 TEXT,
JC009 TEXT,
JC010 TEXT,
JC011 TEXT,
JC012 TEXT,
JC013 TEXT,
JC014 TEXT,
JC015 TEXT,
JC016 TEXT,
JC017 TEXT,
JC018 TEXT,
JC019 TEXT,
JC020 TEXT,
JC021 TEXT,
JC022 TEXT,
JC023 TEXT,
JC024 TEXT,
JC025 TEXT,
JC026 TEXT,
JC027 TEXT,
JC028 TEXT,
JC029 TEXT,
JC030 TEXT,
JC031 TEXT,
JC032 TEXT,
JC033 TEXT,
JC034 TEXT,
JC035 TEXT,
JC036 TEXT,
JC037 TEXT,
JC038 TEXT,
JC039 TEXT,
JC040 TEXT,
JC041 TEXT,
JC042 TEXT,
JC043 TEXT,
JC044 REAL,
JC045 TEXT,
JC046 TEXT,
JC047 TEXT,
JC048 TEXT,
JC049 TEXT,
JC050 TEXT,
JC051 TEXT,
JC052 TEXT,
JC053 TEXT,
JC054 TEXT,
JC055 TEXT,
JC056 TEXT,
JC057 TEXT,
JC058 TEXT,
JC059 TEXT,
JC060 TEXT,
JC061 INTEGER, -- 毒薬フラグ (TEXT -> INTEGER)
JC062 INTEGER, -- 劇薬フラグ (TEXT -> INTEGER)
JC063 INTEGER, -- 麻薬フラグ (TEXT -> INTEGER)
JC064 INTEGER, -- 向精神薬フラグ (TEXT -> INTEGER)
JC065 INTEGER, -- 覚せい剤フラグ (TEXT -> INTEGER)
JC066 INTEGER, -- 覚醒剤原料フラグ (TEXT -> INTEGER)
JC067 TEXT,
JC068 TEXT,
JC069 TEXT,
JC070 TEXT,
JC071 TEXT,
JC072 TEXT,
JC073 TEXT,
JC074 TEXT,
JC075 TEXT,
JC076 TEXT,
JC077 TEXT,
JC078 TEXT,
JC079 TEXT,
JC080 TEXT,
JC081 TEXT,
JC082 TEXT,
JC083 TEXT,
JC084 TEXT,
JC085 TEXT,
JC086 TEXT,
JC087 TEXT,
JC088 TEXT,
JC089 TEXT,
JC090 TEXT,
JC091 TEXT,
JC092 TEXT,
JC093 TEXT,
JC094 TEXT,
JC095 TEXT,
JC096 TEXT,
JC097 TEXT,
JC098 TEXT,
JC099 TEXT,
JC100 TEXT,
JC101 TEXT,
JC102 TEXT,
JC103 TEXT,
JC104 TEXT,
JC105 TEXT,
JC106 TEXT,
JC107 TEXT,
JC108 TEXT,
JC109 TEXT,
JC110 TEXT,
JC111 TEXT,
JC112 TEXT,
JC113 TEXT,
JC114 TEXT,
JC115 TEXT,
JC116 TEXT,
JC117 TEXT,
JC118 TEXT,
JC119 TEXT,
JC120 TEXT,
JC121 TEXT,
JC122 TEXT,
JC123 TEXT,
JC124 TEXT,
PRIMARY KEY(JC000)
);

CREATE TABLE IF NOT EXISTS jancode (
JA000 TEXT,
JA001 TEXT,
JA002 TEXT,
JA003 TEXT,
JA004 TEXT,
JA005 TEXT,
JA006 REAL,    -- JAN側 包装内数量 (TEXT -> REAL)
JA007 TEXT,    -- JAN側 単位コード
JA008 REAL,    -- JAN側 包装単位での数量 (TEXT -> REAL)
JA009 TEXT,
JA010 TEXT,
JA011 TEXT,
JA012 TEXT,
JA013 TEXT,
JA014 TEXT,
JA015 TEXT,
JA016 TEXT,
JA017 TEXT,
JA018 TEXT,
JA019 TEXT,
JA020 TEXT,
JA021 TEXT,
JA022 TEXT,
JA023 TEXT,
JA024 TEXT,
JA025 TEXT,
JA026 TEXT,
JA027 TEXT,
JA028 TEXT,
JA029 TEXT,
PRIMARY KEY(JA001)
);


-- File: Sql/Schema/CreatePartnerMaster.sql

-- パートナーコード → 社名マスター
CREATE TABLE IF NOT EXISTS partner_master (
  id   INTEGER PRIMARY KEY AUTOINCREMENT,
  code TEXT    NOT NULL UNIQUE,    -- パートナーコード
  name TEXT    NOT NULL            -- 社名
);

-- 初期４社登録
INSERT OR IGNORE INTO partner_master (code, name) VALUES
  ('902020014', 'スズケン'),
  ('901660013', 'メディセオ'),
  ('902690019', '中北薬品'),
  ('902960013', 'アルフレッサ');



