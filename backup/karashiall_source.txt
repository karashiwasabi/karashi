----- C:\Dev\KARASHI\central\constants.go -----
// File: central/constants.go
package central

// ProcessFlagMA の値を定数として定義
const (
	FlagComplete    = "COMPLETE"    // データ完了（既存マスタ、またはJCSHMS由来）
	FlagProvisional = "PROVISIONAL" // 暫定データ（最小情報からの自動採番）、継続的な更新対象
)


----- C:\Dev\KARASHI\central\dat_processor.go -----
// File: central/dat_processor.go (修正版)
package central

import (
	"database/sql"
	"fmt"
	"karashi/db"
	"karashi/mappers"
	"karashi/model"
)

func ProcessDatRecords(tx *sql.Tx, conn *sql.DB, records []model.UnifiedInputRecord) ([]model.TransactionRecord, error) {
	if len(records) == 0 {
		return []model.TransactionRecord{}, nil
	}

	keySet := make(map[string]struct{})
	janSet := make(map[string]struct{})
	for _, rec := range records {
		if rec.JanCode != "" && rec.JanCode != "0000000000000" {
			janSet[rec.JanCode] = struct{}{}
		}
		key := rec.JanCode
		if key == "0000000000000" {
			key = fmt.Sprintf("9999999999999%s", rec.ProductName)
		}
		if key != "" {
			keySet[key] = struct{}{}
		}
	}
	keyList := make([]string, 0, len(keySet))
	for key := range keySet {
		keyList = append(keyList, key)
	}
	janList := make([]string, 0, len(janSet))
	for jan := range janSet {
		janList = append(janList, jan)
	}

	mastersMap, err := db.GetProductMastersByCodesMap(conn, keyList)
	if err != nil {
		return nil, fmt.Errorf("failed to bulk get product masters: %w", err)
	}
	jcshmsMap, err := db.GetJcshmsByCodesMap(conn, janList)
	if err != nil {
		return nil, fmt.Errorf("failed to bulk get jcshms: %w", err)
	}

	var finalRecords []model.TransactionRecord
	for _, rec := range records {
		ar := model.TransactionRecord{
			TransactionDate: rec.Date, ClientCode: rec.ClientCode, ReceiptNumber: rec.ReceiptNumber,
			LineNumber: rec.LineNumber, Flag: rec.Flag, JanCode: rec.JanCode,
			ProductName: rec.ProductName, DatQuantity: rec.DatQuantity, UnitPrice: rec.UnitPrice,
			Subtotal: rec.Subtotal, ExpiryDate: rec.ExpiryDate, LotNumber: rec.LotNumber,
		}

		key := ar.JanCode
		if key == "0000000000000" {
			key = fmt.Sprintf("9999999999999%s", ar.ProductName)
		}

		if master, ok := mastersMap[key]; ok {
			if master.Origin == "JCSHMS" {
				ar.ProcessFlagMA = FlagComplete
				ar.ProcessingStatus = sql.NullString{String: "completed", Valid: true}
			} else {
				ar.ProcessFlagMA = FlagProvisional
				ar.ProcessingStatus = sql.NullString{String: "provisional", Valid: true}
			}
			ar.JanQuantity = ar.DatQuantity * master.JanPackUnitQty
			ar.YjQuantity = ar.DatQuantity * master.YjPackUnitQty
			mappers.MapProductMasterToTransaction(&ar, master)
		} else {
			if jcshms, ok := jcshmsMap[ar.JanCode]; ok && jcshms.JC018 != "" {
				ar.ProcessFlagMA = FlagComplete
				ar.ProcessingStatus = sql.NullString{String: "completed", Valid: true}
				yjCode := jcshms.JC009
				if yjCode == "" {
					// ★★★ 呼び出し方を修正 ★★★
					newYj, _ := db.NextSequenceInTx(tx, "MA2Y", "MA2Y", 8)
					yjCode = newYj
				}
				ar.YjCode = yjCode
				mappers.CreateMasterFromJcshmsInTx(tx, ar.JanCode, ar.YjCode, jcshms)
				mappers.MapJcshmsToTransaction(&ar, jcshms)
				ar.JanQuantity = ar.DatQuantity * jcshms.JA008.Float64
				ar.YjQuantity = ar.DatQuantity * jcshms.JC044
			} else {
				ar.ProcessFlagMA = FlagProvisional
				ar.ProcessingStatus = sql.NullString{String: "provisional", Valid: true}

				newYj, productCode, err := createProvisionalMaster(tx, key, ar.JanCode, ar.ProductName, mastersMap)
				if err != nil {
					return nil, err
				}
				ar.YjCode = newYj
				ar.JanCode = productCode

				ar.JanQuantity, ar.YjQuantity = 0, 0
			}
		}
		finalRecords = append(finalRecords, ar)
	}
	return finalRecords, nil
}


----- C:\Dev\KARASHI\central\provisional_master.go -----
// File: central/provisional_master.go (修正版)
package central

import (
	"database/sql"
	"fmt"
	"karashi/db"
	"karashi/model"
)

// createProvisionalMasterは、暫定マスターを作成し、メモリ上のマップを更新する共通関数です。
func createProvisionalMaster(
	tx *sql.Tx,
	key string,
	janCode string,
	productName string,
	mastersMap map[string]*model.ProductMaster,
) (string, string, error) { // yjCodeとproductCodeを返します

	// ★★★ 呼び出し方を修正: プレフィックス"MA2Y"とパディング8桁を追加 ★★★
	newYj, err := db.NextSequenceInTx(tx, "MA2Y", "MA2Y", 8)
	if err != nil {
		return "", "", fmt.Errorf("failed to get next sequence for provisional master: %w", err)
	}

	productCode := janCode
	if key != janCode {
		productCode = key
	}

	minMasterInput := model.ProductMasterInput{
		ProductCode: productCode,
		YjCode:      newYj,
		ProductName: productName,
		Origin:      "PROVISIONAL",
	}

	if err := db.CreateProductMasterInTx(tx, minMasterInput); err != nil {
		return "", "", fmt.Errorf("failed to create provisional master in tx for key %s: %w", key, err)
	}

	newMasterForMap := &model.ProductMaster{
		ProductCode: minMasterInput.ProductCode,
		YjCode:      minMasterInput.YjCode,
		ProductName: minMasterInput.ProductName,
		Origin:      minMasterInput.Origin,
	}
	mastersMap[key] = newMasterForMap

	return newYj, productCode, nil
}


----- C:\Dev\KARASHI\central\usage_processor.go -----
// File: central/usage_processor.go (修正版)
package central

import (
	"database/sql"
	"fmt"
	"karashi/db"
	"karashi/mappers"
	"karashi/model"
)

func ProcessUsageRecords(tx *sql.Tx, conn *sql.DB, records []model.UnifiedInputRecord) ([]model.TransactionRecord, error) {
	if len(records) == 0 {
		return []model.TransactionRecord{}, nil
	}

	keySet := make(map[string]struct{})
	janSet := make(map[string]struct{})
	for _, rec := range records {
		if rec.JanCode != "" {
			janSet[rec.JanCode] = struct{}{}
		}
		key := rec.JanCode
		if key == "" {
			key = fmt.Sprintf("9999999999999%s", rec.ProductName)
		}
		if key != "" {
			keySet[key] = struct{}{}
		}
	}
	keyList := make([]string, 0, len(keySet))
	for key := range keySet {
		keyList = append(keyList, key)
	}
	janList := make([]string, 0, len(janSet))
	for jan := range janSet {
		janList = append(janList, jan)
	}

	mastersMap, err := db.GetProductMastersByCodesMap(conn, keyList)
	if err != nil {
		return nil, fmt.Errorf("failed to bulk get product masters: %w", err)
	}
	jcshmsMap, err := db.GetJcshmsByCodesMap(conn, janList)
	if err != nil {
		return nil, fmt.Errorf("failed to bulk get jcshms: %w", err)
	}

	var finalRecords []model.TransactionRecord
	for _, rec := range records {
		ar := model.TransactionRecord{
			TransactionDate: rec.Date,
			Flag:            3,
			JanCode:         rec.JanCode,
			YjCode:          rec.YjCode,
			ProductName:     rec.ProductName,
			YjQuantity:      rec.YjQuantity,
			YjUnitName:      rec.YjUnitName,
		}

		key := ar.JanCode
		isSyntheticKey := false
		if key == "" {
			key = fmt.Sprintf("9999999999999%s", ar.ProductName)
			isSyntheticKey = true
		}

		if master, ok := mastersMap[key]; ok {
			if master.Origin == "JCSHMS" {
				ar.ProcessFlagMA = FlagComplete
				ar.ProcessingStatus = sql.NullString{String: "completed", Valid: true}
			} else {
				ar.ProcessFlagMA = FlagProvisional
				ar.ProcessingStatus = sql.NullString{String: "provisional", Valid: true}
			}
			ar.JanQuantity = ar.YjQuantity // USAGEではYjQuantityをJanQuantityにコピー
			mappers.MapProductMasterToTransaction(&ar, master)
			ar.JanCode = master.ProductCode
		} else {
			if jcshms, ok := jcshmsMap[ar.JanCode]; ok && jcshms.JC018 != "" {
				ar.ProcessFlagMA = FlagComplete
				ar.ProcessingStatus = sql.NullString{String: "completed", Valid: true}
				yjCode := jcshms.JC009
				if yjCode == "" {
					// ★★★ 呼び出し方を修正 ★★★
					newYj, _ := db.NextSequenceInTx(tx, "MA2Y", "MA2Y", 8)
					yjCode = newYj
				}
				ar.YjCode = yjCode
				mappers.CreateMasterFromJcshmsInTx(tx, ar.JanCode, yjCode, jcshms)
				mappers.MapJcshmsToTransaction(&ar, jcshms)
				ar.JanQuantity = ar.YjQuantity
			} else {
				ar.ProcessFlagMA = FlagProvisional
				ar.ProcessingStatus = sql.NullString{String: "provisional", Valid: true}

				janForMaster := ar.JanCode
				if isSyntheticKey {
					janForMaster = ""
				}
				newYj, productCode, err := createProvisionalMaster(tx, key, janForMaster, ar.ProductName, mastersMap)
				if err != nil {
					return nil, err
				}
				ar.YjCode = newYj
				ar.JanCode = productCode

				ar.JanQuantity = ar.YjQuantity
			}
		}
		finalRecords = append(finalRecords, ar)
	}

	return finalRecords, nil
}


----- C:\Dev\KARASHI\dat\handler.go -----
// File: dat/handler.go
package dat

import (
	"database/sql"
	"encoding/json"
	"karashi/central"
	"karashi/db"
	"karashi/model"
	"log"
	"net/http"
)

func UploadDatHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		if r.Method != http.MethodPost {
			http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
			return
		}
		if err := r.ParseMultipartForm(32 << 20); err != nil {
			http.Error(w, "File upload error: "+err.Error(), http.StatusBadRequest)
			return
		}
		defer r.MultipartForm.RemoveAll()

		var allParsedRecords []model.UnifiedInputRecord
		for _, fileHeader := range r.MultipartForm.File["file"] {
			file, err := fileHeader.Open()
			if err != nil {
				log.Printf("Failed to open file %s: %v", fileHeader.Filename, err)
				continue
			}
			defer file.Close()
			parsed, err := ParseDat(file)
			if err != nil {
				log.Printf("Failed to parse file %s: %v", fileHeader.Filename, err)
				continue
			}
			allParsedRecords = append(allParsedRecords, parsed...)
		}

		// ✨ ここからが新しい高速化処理 ✨
		// トランザクションを開始
		tx, err := conn.Begin()
		if err != nil {
			http.Error(w, "Failed to begin transaction", http.StatusInternalServerError)
			return
		}
		defer tx.Rollback()

		// 新しい一括処理関数を呼び出す
		finalRecords, err := central.ProcessDatRecords(tx, conn, allParsedRecords)
		if err != nil {
			log.Printf("central.ProcessDatRecords failed: %v", err)
			http.Error(w, "internal server error", http.StatusInternalServerError)
			return
		}

		if len(finalRecords) > 0 {
			if err := db.PersistTransactionRecordsInTx(tx, finalRecords); err != nil {
				log.Printf("db.PersistTransactionRecordsInTx error: %v", err)
				http.Error(w, "internal server error", http.StatusInternalServerError)
				return
			}
		}

		if err := tx.Commit(); err != nil {
			log.Printf("transaction commit error: %v", err)
			http.Error(w, "internal server error", http.StatusInternalServerError)
			return
		}
		// ✨ ここまで ✨

		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		json.NewEncoder(w).Encode(map[string]interface{}{
			"message": "Parsed and processed DAT files successfully",
			"records": finalRecords,
		})
	}
}


----- C:\Dev\KARASHI\dat\parser.go -----
// File: dat/parser.go
package dat

import (
	"bufio"
	"io"
	"karashi/model"
	"strconv"
	"strings"

	"golang.org/x/text/encoding/japanese"
	"golang.org/x/text/transform"
)

// ParseDatは、固定長のDATファイルからレコードを抽出し、UnifiedInputRecordのスライスを返します。
func ParseDat(r io.Reader) ([]model.UnifiedInputRecord, error) {
	scanner := bufio.NewScanner(r)
	var records []model.UnifiedInputRecord
	var currentWholesale string

	for scanner.Scan() {
		line := scanner.Text()
		if len(line) == 0 {
			continue
		}

		switch line[0:1] {
		case "S":
			if len(line) >= 13 {
				currentWholesale = strings.TrimSpace(line[2:13])
			}
		case "D":
			if len(line) < 121 {
				line += strings.Repeat(" ", 121-len(line))
			}

			// 型変換をここで行う
			productNameSJIS := line[38:78]
			utf8Bytes, _, _ := transform.Bytes(japanese.ShiftJIS.NewDecoder(), []byte(productNameSJIS))

			flag, _ := strconv.Atoi(strings.TrimSpace(line[3:4]))
			datqty, _ := strconv.ParseFloat(strings.TrimSpace(line[78:83]), 64)
			unitprice, _ := strconv.ParseFloat(strings.TrimSpace(line[83:92]), 64)
			subtotal, _ := strconv.ParseFloat(strings.TrimSpace(line[92:101]), 64)

			// UnifiedInputRecordを直接構築
			rec := model.UnifiedInputRecord{
				ClientCode:    currentWholesale,
				Flag:          flag,
				Date:          strings.TrimSpace(line[4:12]),
				ReceiptNumber: strings.TrimSpace(line[12:22]),
				LineNumber:    strings.TrimSpace(line[22:24]),
				JanCode:       strings.TrimSpace(line[25:38]),
				ProductName:   strings.TrimSpace(string(utf8Bytes)),
				DatQuantity:   datqty,
				UnitPrice:     unitprice,
				Subtotal:      subtotal,
				ExpiryDate:    strings.TrimSpace(line[109:115]), // 文字列として直接格納
				LotNumber:     strings.TrimSpace(line[115:121]),
			}
			records = append(records, rec)
		}
	}
	return records, scanner.Err()
}


----- C:\Dev\KARASHI\db\clients.go -----
// File: db/clients.go (新規作成)
package db

import (
	"database/sql"
	"fmt"
	"karashi/model"
)

// GetAllClientsは、得意先マスターから全件取得します。
func GetAllClients(conn *sql.DB) ([]model.Client, error) {
	rows, err := conn.Query("SELECT client_code, client_name FROM client_master ORDER BY client_code")
	if err != nil {
		return nil, fmt.Errorf("failed to get all clients: %w", err)
	}
	defer rows.Close()

	var clients []model.Client
	for rows.Next() {
		var c model.Client
		if err := rows.Scan(&c.Code, &c.Name); err != nil {
			return nil, err
		}
		clients = append(clients, c)
	}
	return clients, nil
}


----- C:\Dev\KARASHI\db\jcshms.go -----
// File: db/jcshms.go (修正版)
package db

import (
	"database/sql"
	"fmt"
	"karashi/model"
	"log" // ★ ログ出力のためにインポート
	"strconv"
	"strings"
)

// (GetJcshmsByJan関数は変更なし)
func GetJcshmsByJan(conn *sql.DB, jan string) (*model.JCShms, error) {
	// ...
	return nil, nil
}

func GetJcshmsByCodesMap(conn *sql.DB, jans []string) (map[string]*model.JCShms, error) {
	if len(jans) == 0 {
		return make(map[string]*model.JCShms), nil
	}

	results := make(map[string]*model.JCShms)

	inClause := `(?` + strings.Repeat(",?", len(jans)-1) + `)`
	args := make([]interface{}, len(jans))
	for i, jan := range jans {
		args[i] = jan
		results[jan] = &model.JCShms{}
	}

	q1 := `SELECT JC000, JC009, JC018, JC022, JC030, JC037, JC039, JC044, JC050,
	              JC061, JC062, JC063, JC064, JC065, JC066
	       FROM jcshms WHERE JC000 IN ` + inClause

	rows1, err := conn.Query(q1, args...)
	if err != nil {
		return nil, fmt.Errorf("jcshms bulk search failed: %w", err)
	}
	defer rows1.Close()

	for rows1.Next() {
		var jan string
		var jcshmsPart model.JCShms
		var jc050 sql.NullString // ★★★ JC050を安全に読み込むため、一時的に文字列型で受け取る

		if err := rows1.Scan(&jan, &jcshmsPart.JC009, &jcshmsPart.JC018, &jcshmsPart.JC022, &jcshmsPart.JC030,
			&jcshmsPart.JC037, &jcshmsPart.JC039, &jcshmsPart.JC044, &jc050, // ★★★ スキャン先をjc050に変更
			&jcshmsPart.JC061, &jcshmsPart.JC062, &jcshmsPart.JC063, &jcshmsPart.JC064, &jcshmsPart.JC065, &jcshmsPart.JC066,
		); err != nil {
			return nil, err
		}

		res := results[jan]
		res.JC009 = jcshmsPart.JC009
		res.JC018 = jcshmsPart.JC018
		res.JC022 = jcshmsPart.JC022
		res.JC030 = jcshmsPart.JC030
		res.JC037 = jcshmsPart.JC037
		res.JC039 = jcshmsPart.JC039
		res.JC044 = jcshmsPart.JC044
		res.JC061 = jcshmsPart.JC061
		res.JC062 = jcshmsPart.JC062
		res.JC063 = jcshmsPart.JC063
		res.JC064 = jcshmsPart.JC064
		res.JC065 = jcshmsPart.JC065
		res.JC066 = jcshmsPart.JC066

		// ★★★ ここからがJC050を安全に数値へ変換する処理 ★★★
		val, err := strconv.ParseFloat(jc050.String, 64)
		if err != nil {
			// 変換に失敗した場合(空文字など)は0を設定し、ログを出力
			res.JC050 = 0
			if jc050.String != "" { // 完全な空文字はログに出さない場合
				log.Printf("[WARN] JC050のデータが不正なため0に変換しました。製品名: %s, 元の値: '%s'", res.JC018, jc050.String)
			}
		} else {
			// 変換に成功した場合はその値を設定
			res.JC050 = val
		}
		// ★★★ ここまで ★★★
	}

	q2 := `SELECT JA001, JA006, JA007, JA008 FROM jancode WHERE JA001 IN ` + inClause

	rows2, err := conn.Query(q2, args...)
	if err != nil {
		return nil, fmt.Errorf("jancode bulk search failed: %w", err)
	}
	defer rows2.Close()

	for rows2.Next() {
		var jan string
		var jaPart struct {
			JA006 sql.NullFloat64
			JA007 sql.NullString
			JA008 sql.NullFloat64
		}
		if err := rows2.Scan(&jan, &jaPart.JA006, &jaPart.JA007, &jaPart.JA008); err != nil {
			return nil, err
		}
		results[jan].JA006 = jaPart.JA006
		results[jan].JA007 = jaPart.JA007
		results[jan].JA008 = jaPart.JA008
	}

	return results, nil
}


----- C:\Dev\KARASHI\db\product_master.go -----
// File: db/product_master.go
package db

import (
	"database/sql"
	"fmt"
	"karashi/model"
	"strings"
)

// ★★★ 全てのSELECT文で使う共通の列リストを定義 ★★★
const selectColumns = `
	product_code, yj_code, product_name, origin, kana_name, maker_name, package_spec, 
	yj_unit_name, yj_pack_unit_qty, flag_poison, flag_deleterious, flag_narcotic, 
	flag_psychotropic, flag_stimulant, flag_stimulant_raw, jan_pack_inner_qty, 
	jan_unit_code, jan_pack_unit_qty, reorder_point, nhi_price`

// ★★★ 共通のスキャン関数を定義 ★★★
func scanProductMaster(row interface{ Scan(...interface{}) error }) (*model.ProductMaster, error) {
	var m model.ProductMaster
	err := row.Scan(
		&m.ProductCode, &m.YjCode, &m.ProductName, &m.Origin, &m.KanaName, &m.MakerName, &m.PackageSpec,
		&m.YjUnitName, &m.YjPackUnitQty, &m.FlagPoison, &m.FlagDeleterious, &m.FlagNarcotic,
		&m.FlagPsychotropic, &m.FlagStimulant, &m.FlagStimulantRaw, &m.JanPackInnerQty,
		&m.JanUnitCode, &m.JanPackUnitQty, &m.ReorderPoint, &m.NhiPrice,
	)
	if err != nil {
		return nil, err
	}
	return &m, nil
}

// GetProductMasterByCodeは、製品コードをキーにマスターを取得します。
func GetProductMasterByCode(conn *sql.DB, code string) (*model.ProductMaster, error) {
	q := `SELECT ` + selectColumns + ` FROM product_master WHERE product_code = ? LIMIT 1`
	m, err := scanProductMaster(conn.QueryRow(q, code))
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, fmt.Errorf("GetProductMasterByCode failed: %w", err)
	}
	return m, nil
}

// GetProductMastersByCodesMapは、複数の製品コードをキーにマスターのマップを返します。
func GetProductMastersByCodesMap(conn *sql.DB, codes []string) (map[string]*model.ProductMaster, error) {
	if len(codes) == 0 {
		return make(map[string]*model.ProductMaster), nil
	}
	q := `SELECT ` + selectColumns + ` FROM product_master WHERE product_code IN (?` + strings.Repeat(",?", len(codes)-1) + `)`
	args := make([]interface{}, len(codes))
	for i, code := range codes {
		args[i] = code
	}
	rows, err := conn.Query(q, args...)
	if err != nil {
		return nil, fmt.Errorf("query for masters by codes failed: %w", err)
	}
	defer rows.Close()
	mastersMap := make(map[string]*model.ProductMaster)
	for rows.Next() {
		m, err := scanProductMaster(rows)
		if err != nil {
			return nil, err
		}
		mastersMap[m.ProductCode] = m
	}
	return mastersMap, nil
}

// GetProductMasterByNameは、製品名をキーにマスターを取得します。
func GetProductMasterByName(conn *sql.DB, name string) (*model.ProductMaster, error) {
	q := `SELECT ` + selectColumns + ` FROM product_master WHERE product_name = ? LIMIT 1`
	m, err := scanProductMaster(conn.QueryRow(q, name))
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, fmt.Errorf("GetProductMasterByName failed: %w", err)
	}
	return m, nil
}

// CreateProductMasterInTxは、既存のトランザクション内でマスターを作成します。
func CreateProductMasterInTx(tx *sql.Tx, rec model.ProductMasterInput) error {
	const q = `INSERT INTO product_master (
			product_code, yj_code, product_name, origin, kana_name, maker_name, package_spec, 
			yj_unit_name, yj_pack_unit_qty, flag_poison, flag_deleterious, flag_narcotic, 
			flag_psychotropic, flag_stimulant, flag_stimulant_raw, jan_pack_inner_qty, 
			jan_unit_code, jan_pack_unit_qty, reorder_point, nhi_price
		) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`
	_, err := tx.Exec(q,
		rec.ProductCode, rec.YjCode, rec.ProductName, rec.Origin, rec.KanaName, rec.MakerName, rec.PackageSpec,
		rec.YjUnitName, rec.YjPackUnitQty, rec.FlagPoison, rec.FlagDeleterious, rec.FlagNarcotic,
		rec.FlagPsychotropic, rec.FlagStimulant, rec.FlagStimulantRaw, rec.JanPackInnerQty,
		rec.JanUnitCode, rec.JanPackUnitQty, rec.ReorderPoint, rec.NhiPrice,
	)
	if err != nil {
		return fmt.Errorf("CreateProductMasterInTx failed: %w", err)
	}
	return nil
}

// UpdateProductMasterInTxは、既存のトランザクション内でマスターを更新します。
func UpdateProductMasterInTx(tx *sql.Tx, rec model.ProductMasterInput) error {
	const q = `UPDATE product_master SET
            yj_code = ?, product_name = ?, origin = ?, kana_name = ?, maker_name = ?, package_spec = ?, 
            yj_unit_name = ?, yj_pack_unit_qty = ?, flag_poison = ?, flag_deleterious = ?, 
            flag_narcotic = ?, flag_psychotropic = ?, flag_stimulant = ?, flag_stimulant_raw = ?, 
            jan_pack_inner_qty = ?, jan_unit_code = ?, jan_pack_unit_qty = ?, reorder_point = ?, nhi_price = ?
			WHERE product_code = ?`
	_, err := tx.Exec(q,
		rec.YjCode, rec.ProductName, rec.Origin, rec.KanaName, rec.MakerName, rec.PackageSpec,
		rec.YjUnitName, rec.YjPackUnitQty, rec.FlagPoison, rec.FlagDeleterious,
		rec.FlagNarcotic, rec.FlagPsychotropic, rec.FlagStimulant, rec.FlagStimulantRaw,
		rec.JanPackInnerQty, rec.JanUnitCode, rec.JanPackUnitQty, rec.ReorderPoint, rec.NhiPrice,
		rec.ProductCode,
	)
	if err != nil {
		return fmt.Errorf("UpdateProductMasterInTx failed: %w", err)
	}
	return nil
}

// GetProductMasterByCodeInTxは、既存のトランザクション内で製品コードをキーにマスターを取得します。
func GetProductMasterByCodeInTx(tx *sql.Tx, code string) (*model.ProductMaster, error) {
	q := `SELECT ` + selectColumns + ` FROM product_master WHERE product_code = ? LIMIT 1`
	m, err := scanProductMaster(tx.QueryRow(q, code))
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, fmt.Errorf("GetProductMasterByCodeInTx failed: %w", err)
	}
	return m, nil
}

// GetAllProductMastersは、製品マスターを全件取得します。
func GetAllProductMasters(conn *sql.DB) ([]*model.ProductMaster, error) {
	q := `SELECT ` + selectColumns + ` FROM product_master ORDER BY kana_name`

	rows, err := conn.Query(q)
	if err != nil {
		return nil, fmt.Errorf("GetAllProductMasters failed: %w", err)
	}
	defer rows.Close()

	var masters []*model.ProductMaster
	for rows.Next() {
		m, err := scanProductMaster(rows)
		if err != nil {
			return nil, err
		}
		masters = append(masters, m)
	}
	return masters, nil
}

// SearchProductMastersByNameは、製品名の一部に一致するマスターのリストを返します。
func SearchProductMastersByName(conn *sql.DB, nameQuery string) ([]*model.ProductMaster, error) {
	q := `SELECT ` + selectColumns + ` FROM product_master WHERE product_name LIKE ? OR kana_name LIKE ? ORDER BY kana_name LIMIT 100`

	rows, err := conn.Query(q, "%"+nameQuery+"%", "%"+nameQuery+"%")
	if err != nil {
		return nil, fmt.Errorf("SearchProductMastersByName failed: %w", err)
	}
	defer rows.Close()

	var masters []*model.ProductMaster
	for rows.Next() {
		m, err := scanProductMaster(rows)
		if err != nil {
			return nil, err
		}
		masters = append(masters, m)
	}
	return masters, nil
}


----- C:\Dev\KARASHI\db\search.go -----
// File: db/search.go (修正版)
package db

import (
	"database/sql"
	"fmt"
	"karashi/model"
	"karashi/units"
	"log" // ★ ログ出力のためにインポート
	"strconv"
)

func SearchJcshmsByName(conn *sql.DB, nameQuery string) ([]model.ProductMasterView, error) {
	const q = `
		SELECT
			j.JC000, j.JC009, j.JC018, j.JC022, j.JC030, j.JC037, j.JC039,
			j.JC044, j.JC050,
			ja.JA006, ja.JA008, ja.JA007
		FROM
			jcshms AS j
		LEFT JOIN
			jancode AS ja ON j.JC000 = ja.JA001
		WHERE
			j.JC018 LIKE ? OR j.JC022 LIKE ?
		ORDER BY
			j.JC022
		LIMIT 500`

	rows, err := conn.Query(q, "%"+nameQuery+"%", "%"+nameQuery+"%")
	if err != nil {
		return nil, fmt.Errorf("SearchJcshmsByName failed: %w", err)
	}
	defer rows.Close()

	var results []model.ProductMasterView
	for rows.Next() {
		var tempJcshms model.JCShms
		var jc000, jc009, jc018, jc022, jc030, jc037, jc039 sql.NullString
		var jc044 sql.NullFloat64
		var jc050 sql.NullString // ★★★ JC050を安全に読み込むため、一時的に文字列型で受け取る

		if err := rows.Scan(
			&jc000, &jc009, &jc018, &jc022, &jc030, &jc037, &jc039,
			&jc044, &jc050, // ★★★ スキャン先をjc050に変更
			&tempJcshms.JA006, &tempJcshms.JA008, &tempJcshms.JA007,
		); err != nil {
			return nil, err
		}

		tempJcshms.JC037 = jc037.String
		tempJcshms.JC039 = jc039.String
		tempJcshms.JC044 = jc044.Float64

		// ★★★ ここからがJC050を安全に数値へ変換する処理 ★★★
		val, err := strconv.ParseFloat(jc050.String, 64)
		if err != nil {
			tempJcshms.JC050 = 0
			if jc050.String != "" {
				log.Printf("[WARN] JC050のデータが不正なため0に変換しました。製品名: %s, 元の値: '%s'", jc018.String, jc050.String)
			}
		} else {
			tempJcshms.JC050 = val
		}
		// ★★★ ここまで ★★★

		var nhiPrice float64
		if tempJcshms.JC044 > 0 {
			nhiPrice = tempJcshms.JC050 / tempJcshms.JC044
		}

		pkg := units.FormatPackageSpec(&tempJcshms)

		yjUnitName := units.ResolveName(jc039.String)
		janUnitCode := tempJcshms.JA007.String
		var janUnitName string
		if janUnitCode == "0" || janUnitCode == "" {
			janUnitName = yjUnitName
		} else {
			janUnitName = units.ResolveName(janUnitCode)
		}

		view := model.ProductMasterView{
			ProductMaster: model.ProductMaster{
				ProductCode:     jc000.String,
				YjCode:          jc009.String,
				ProductName:     jc018.String,
				KanaName:        jc022.String,
				MakerName:       jc030.String,
				PackageSpec:     jc037.String,
				YjUnitName:      yjUnitName,
				JanUnitName:     janUnitName,
				YjPackUnitQty:   jc044.Float64,
				JanPackInnerQty: tempJcshms.JA006.Float64,
				JanPackUnitQty:  tempJcshms.JA008.Float64,
				NhiPrice:        nhiPrice,
			},
			FormattedPackageSpec: pkg,
		}
		results = append(results, view)
	}
	return results, nil
}


----- C:\Dev\KARASHI\db\sequence.go -----
// File: db/sequence.go (修正版)
package db

import (
	"database/sql"
	"fmt"
)

// NextSequenceInTxは、指定されたシーケンスから次の番号を生成します。
// 例: (tx, "CL", "CL", 4) -> "CL0001"
func NextSequenceInTx(tx *sql.Tx, name, prefix string, padding int) (string, error) {
	var lastNo int

	err := tx.QueryRow("SELECT last_no FROM code_sequences WHERE name = ?", name).Scan(&lastNo)
	if err != nil {
		if err == sql.ErrNoRows {
			return "", fmt.Errorf("シーケンス '%s' が見つかりません", name)
		}
		return "", fmt.Errorf("シーケンス '%s' の取得に失敗しました: %w", name, err)
	}

	newNo := lastNo + 1

	_, err = tx.Exec("UPDATE code_sequences SET last_no = ? WHERE name = ?", newNo, name)
	if err != nil {
		return "", fmt.Errorf("シーケンス '%s' の更新に失敗しました: %w", name, err)
	}

	format := fmt.Sprintf("%s%%0%dd", prefix, padding)
	return fmt.Sprintf(format, newNo), nil
}


----- C:\Dev\KARASHI\db\transaction_records.go -----
// File: db/transaction_records.go
package db

import (
	"database/sql"
	"fmt"
	"karashi/model"
	"log"
)

// PersistTransactionRecordsは、新しいトランザクションを開始してレコードを保存します。
func PersistTransactionRecords(conn *sql.DB, records []model.TransactionRecord) error {
	tx, err := conn.Begin()
	if err != nil {
		return fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer tx.Rollback()

	if err := PersistTransactionRecordsInTx(tx, records); err != nil {
		return err
	}

	return tx.Commit()
}

// PersistTransactionRecordsInTxは、既存のトランザクション内でレコードを保存します。
func PersistTransactionRecordsInTx(tx *sql.Tx, records []model.TransactionRecord) error {
	const q = `
INSERT OR REPLACE INTO transaction_records (
    transaction_date, client_code, receipt_number, line_number, flag,
    jan_code, yj_code, product_name, kana_name, package_form, package_spec, maker_name,
    dat_quantity, jan_pack_inner_qty, jan_quantity, jan_pack_unit_qty, jan_unit_name, jan_unit_code,
    yj_quantity, yj_pack_unit_qty, yj_unit_name, unit_price, subtotal,
    tax_amount, tax_rate, expiry_date, lot_number, flag_poison,
    flag_deleterious, flag_narcotic, flag_psychotropic, flag_stimulant,
    flag_stimulant_raw, process_flag_ma, processing_status
) VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)`

	stmt, err := tx.Prepare(q)
	if err != nil {
		return fmt.Errorf("failed to prepare statement for transaction_records: %w", err)
	}
	defer stmt.Close()

	for _, rec := range records {
		_, err := stmt.Exec(
			rec.TransactionDate, rec.ClientCode, rec.ReceiptNumber, rec.LineNumber, rec.Flag,
			rec.JanCode, rec.YjCode, rec.ProductName, rec.KanaName, rec.PackageForm, rec.PackageSpec, rec.MakerName,
			rec.DatQuantity, rec.JanPackInnerQty, rec.JanQuantity,
			rec.JanPackUnitQty,
			rec.JanUnitName, rec.JanUnitCode,
			rec.YjQuantity, rec.YjPackUnitQty, rec.YjUnitName, rec.UnitPrice, rec.Subtotal,
			rec.TaxAmount, rec.TaxRate, rec.ExpiryDate, rec.LotNumber, rec.FlagPoison,
			rec.FlagDeleterious, rec.FlagNarcotic, rec.FlagPsychotropic, rec.FlagStimulant,
			rec.FlagStimulantRaw, rec.ProcessFlagMA, rec.ProcessingStatus,
		)
		if err != nil {
			log.Printf("!!! FAILED to insert into transaction_records: JAN=%s, Error: %v", rec.JanCode, err)
			return fmt.Errorf("failed to exec statement for transaction_records (JAN: %s): %w", rec.JanCode, err)
		}
	}
	return nil
}

// GetReceiptNumbersByDateは、指定された日付に存在する伝票番号のリストを返します。
func GetReceiptNumbersByDate(conn *sql.DB, date string) ([]string, error) {
	rows, err := conn.Query("SELECT DISTINCT receipt_number FROM transaction_records WHERE transaction_date = ? ORDER BY receipt_number", date)
	if err != nil {
		return nil, fmt.Errorf("failed to get receipt numbers by date: %w", err)
	}
	defer rows.Close()

	var numbers []string
	for rows.Next() {
		var number string
		if err := rows.Scan(&number); err != nil {
			return nil, err
		}
		numbers = append(numbers, number)
	}
	return numbers, nil
}

// GetTransactionsByReceiptNumberは、指定された伝票番号の全明細を返します。
func GetTransactionsByReceiptNumber(conn *sql.DB, receiptNumber string) ([]model.TransactionRecord, error) {
	q := `SELECT
		transaction_date, client_code, receipt_number, line_number, flag,
		jan_code, yj_code, product_name, kana_name, package_form, package_spec, maker_name,
		dat_quantity, jan_pack_inner_qty, jan_quantity, jan_pack_unit_qty, jan_unit_name, jan_unit_code,
		yj_quantity, yj_pack_unit_qty, yj_unit_name, unit_price, subtotal,
		tax_amount, tax_rate, expiry_date, lot_number
	FROM transaction_records WHERE receipt_number = ? ORDER BY line_number`

	rows, err := conn.Query(q, receiptNumber)
	if err != nil {
		return nil, fmt.Errorf("failed to get transactions by receipt number: %w", err)
	}
	defer rows.Close()

	var records []model.TransactionRecord
	for rows.Next() {
		var r model.TransactionRecord
		// 注意: Scanするフィールドの数と順番をSELECT文と正確に合わせる必要があります
		if err := rows.Scan(
			&r.TransactionDate, &r.ClientCode, &r.ReceiptNumber, &r.LineNumber, &r.Flag,
			&r.JanCode, &r.YjCode, &r.ProductName, &r.KanaName, &r.PackageForm, &r.PackageSpec, &r.MakerName,
			&r.DatQuantity, &r.JanPackInnerQty, &r.JanQuantity, &r.JanPackUnitQty, &r.JanUnitName, &r.JanUnitCode,
			&r.YjQuantity, &r.YjPackUnitQty, &r.YjUnitName, &r.UnitPrice, &r.Subtotal,
			&r.TaxAmount, &r.TaxRate, &r.ExpiryDate, &r.LotNumber,
		); err != nil {
			return nil, err
		}
		records = append(records, r)
	}
	return records, nil
}

// ★★★ ADD THE FOLLOWING FUNCTION ★★★
// DeleteTransactionsByReceiptNumberInTx deletes all records for a given receipt number within a transaction.
func DeleteTransactionsByReceiptNumberInTx(tx *sql.Tx, receiptNumber string) error {
	const q = `DELETE FROM transaction_records WHERE receipt_number = ?`

	result, err := tx.Exec(q, receiptNumber)
	if err != nil {
		return fmt.Errorf("failed to delete transactions for receipt %s: %w", receiptNumber, err)
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return fmt.Errorf("failed to get rows affected for receipt %s: %w", receiptNumber, err)
	}

	if rowsAffected == 0 {
		return fmt.Errorf("no transaction found with receipt number: %s", receiptNumber)
	}

	return nil
}


----- C:\Dev\KARASHI\db\usage.go -----
// File: db/usage.go
package db

import (
	"database/sql"
	"fmt"
)

// DeleteUsageTransactionsInDateRangeは、指定された日付範囲内のUSAGEレコード(flag=3)を削除します。
func DeleteUsageTransactionsInDateRange(tx *sql.Tx, minDate, maxDate string) error {
	const q = `DELETE FROM transaction_records WHERE flag = 3 AND transaction_date BETWEEN ? AND ?`
	_, err := tx.Exec(q, minDate, maxDate)
	if err != nil {
		return fmt.Errorf("failed to delete usage transactions: %w", err)
	}
	return nil
}


----- C:\Dev\KARASHI\inout\handler.go -----
// File: inout/handler.go (Corrected)
package inout

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"karashi/db"
	"karashi/model"
	"log"
	"net/http"
	"time"
)

// SavePayload is the structure for the JSON sent from the frontend.
type SavePayload struct {
	IsNewClient     bool                      `json:"isNewClient"`
	ClientCode      string                    `json:"clientCode"`
	ClientName      string                    `json:"clientName"`
	TransactionDate string                    `json:"transactionDate"`
	TransactionType string                    `json:"transactionType"`
	Records         []model.TransactionRecord `json:"records"`
}

// SaveInOutHandler handles saving In/Out data.
func SaveInOutHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var payload SavePayload
		if err := json.NewDecoder(r.Body).Decode(&payload); err != nil {
			http.Error(w, "Invalid request body", http.StatusBadRequest)
			return
		}

		tx, err := conn.Begin()
		if err != nil {
			http.Error(w, "Failed to start transaction", http.StatusInternalServerError)
			return
		}
		defer tx.Rollback()

		// --- Client Handling ---
		clientCode := payload.ClientCode
		if payload.IsNewClient {
			var exists int
			err := tx.QueryRow("SELECT 1 FROM client_master WHERE client_name = ? LIMIT 1", payload.ClientName).Scan(&exists)
			if err != sql.ErrNoRows {
				if err == nil {
					w.WriteHeader(http.StatusConflict)
					json.NewEncoder(w).Encode(map[string]string{"message": fmt.Sprintf("Client name '%s' is already in use.", payload.ClientName)})
				} else {
					http.Error(w, "Failed to check client existence", http.StatusInternalServerError)
				}
				return
			}

			newCode, err := db.NextSequenceInTx(tx, "CL", "CL", 4)
			if err != nil {
				http.Error(w, "Failed to generate new client code", http.StatusInternalServerError)
				return
			}

			_, err = tx.Exec("INSERT INTO client_master (client_code, client_name) VALUES (?, ?)", newCode, payload.ClientName)
			if err != nil {
				http.Error(w, "Failed to create new client", http.StatusInternalServerError)
				return
			}
			clientCode = newCode
		}

		// --- Receipt Number Generation ---
		dateStr := payload.TransactionDate
		if dateStr == "" {
			dateStr = time.Now().Format("20060102")
		}

		var lastSeq int
		q := `SELECT CAST(SUBSTR(receipt_number, 11) AS INTEGER) FROM transaction_records 
		      WHERE receipt_number LIKE ? ORDER BY 1 DESC LIMIT 1`
		err = tx.QueryRow(q, "io"+dateStr+"%").Scan(&lastSeq)
		if err != nil && err != sql.ErrNoRows {
			http.Error(w, "Failed to get last receipt number sequence", http.StatusInternalServerError)
			return
		}
		newSeq := lastSeq + 1
		receiptNumber := fmt.Sprintf("io%s%03d", dateStr, newSeq)

		// --- Record Saving ---
		flagMap := map[string]int{"入庫": 1, "出庫": 2}
		flag := flagMap[payload.TransactionType]

		for i := range payload.Records {
			rec := &payload.Records[i]
			rec.ClientCode = clientCode
			rec.ReceiptNumber = receiptNumber
			rec.TransactionDate = dateStr
			rec.Flag = flag
			rec.ProcessFlagMA = "COMPLETE"
			rec.ProcessingStatus = sql.NullString{String: "completed", Valid: true}

			// *** ADDED LOGIC: Check and create product master if it doesn't exist ***
			if rec.JanCode != "" {
				master, err := db.GetProductMasterByCodeInTx(tx, rec.JanCode)
				if err != nil {
					http.Error(w, "Failed to check product master", http.StatusInternalServerError)
					return
				}
				if master == nil { // If master doesn't exist, create it
					newMaster := model.ProductMasterInput{
						ProductCode:      rec.JanCode,
						YjCode:           rec.YjCode,
						ProductName:      rec.ProductName,
						Origin:           "MANUAL_ENTRY",
						KanaName:         rec.KanaName,
						MakerName:        rec.MakerName,
						PackageSpec:      rec.PackageForm,
						YjUnitName:       rec.YjUnitName,
						YjPackUnitQty:    rec.YjPackUnitQty,
						JanPackInnerQty:  rec.JanPackInnerQty,
						JanPackUnitQty:   rec.JanPackUnitQty,
						FlagPoison:       rec.FlagPoison,
						FlagDeleterious:  rec.FlagDeleterious,
						FlagNarcotic:     rec.FlagNarcotic,
						FlagPsychotropic: rec.FlagPsychotropic,
						FlagStimulant:    rec.FlagStimulant,
						FlagStimulantRaw: rec.FlagStimulantRaw,
					}
					if err := db.CreateProductMasterInTx(tx, newMaster); err != nil {
						http.Error(w, "Failed to create new product master", http.StatusInternalServerError)
						return
					}
				}
			}
		}

		if err := db.PersistTransactionRecordsInTx(tx, payload.Records); err != nil {
			log.Printf("Failed to persist records: %v", err)
			w.WriteHeader(http.StatusInternalServerError)
			json.NewEncoder(w).Encode(map[string]string{"message": "Database save failed."})
			return
		}

		if err := tx.Commit(); err != nil {
			http.Error(w, "Failed to commit transaction", http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{
			"message":       "Saved successfully",
			"receiptNumber": receiptNumber,
		})
	}
}


----- C:\Dev\KARASHI\loader\loader.go -----
// File: loader/loader.go
package loader

import (
	"database/sql"
	"encoding/csv"
	"fmt"
	"io"
	"os"
	"strconv"
	"strings"

	"golang.org/x/text/encoding/japanese"
	"golang.org/x/text/transform"
)

// ★★★ ここにJC050の定義を追加 ★★★
var tableSchemas = map[string]map[int]string{
	"jcshms": {
		44: "real", // JC044
		50: "real", // JC050 (薬価)
		61: "int",
		62: "int",
		63: "int",
		64: "int",
		65: "int",
		66: "int",
	},
	"jancode": {
		7: "real", // JA006
		9: "real", // JA008
	},
}

func InitDatabase(db *sql.DB) error {
	if err := applySchema(db); err != nil {
		return fmt.Errorf("schema.sql 読み込み失敗: %w", err)
	}
	if err := loadCSV(db, "SOU/JCSHMS.CSV", "jcshms", 125, false); err != nil {
		return fmt.Errorf("JCSHMS 読み込み失敗: %w", err)
	}
	if err := loadCSV(db, "SOU/JANCODE.CSV", "jancode", 30, true); err != nil {
		return fmt.Errorf("JANCODE 読み込み失敗: %w", err)
	}
	return nil
}

func applySchema(db *sql.DB) error {
	schema, err := os.ReadFile("schema.sql")
	if err != nil {
		return err
	}
	_, err = db.Exec(string(schema))
	return err
}

func loadCSV(db *sql.DB, filepath, tablename string, columns int, skipHeader bool) error {
	f, err := os.Open(filepath)
	if err != nil {
		return err
	}
	defer f.Close()

	r := csv.NewReader(transform.NewReader(f, japanese.ShiftJIS.NewDecoder()))
	r.LazyQuotes = true
	r.FieldsPerRecord = -1
	if skipHeader {
		if _, err := r.Read(); err != nil && err != io.EOF {
			return err
		}
	}

	tx, err := db.Begin()
	if err != nil {
		return err
	}
	defer tx.Rollback()

	placeholders := make([]string, columns)
	for i := 0; i < columns; i++ {
		placeholders[i] = "?"
	}
	stmt, err := tx.Prepare(fmt.Sprintf(
		"INSERT OR REPLACE INTO %s VALUES (%s)",
		tablename, strings.Join(placeholders, ","),
	))
	if err != nil {
		return err
	}
	defer stmt.Close()

	schema := tableSchemas[tablename]

	for {
		row, err := r.Read()
		if err == io.EOF {
			break
		}
		if err != nil || len(row) < columns {
			continue
		}

		args := make([]interface{}, columns)
		for i, val := range row {
			if i >= columns {
				break
			}
			colType, isNumeric := schema[i+1]
			if isNumeric {
				switch colType {
				case "real":
					num, _ := strconv.ParseFloat(strings.TrimSpace(val), 64)
					args[i] = num
				case "int":
					num, _ := strconv.ParseInt(strings.TrimSpace(val), 10, 64)
					args[i] = num
				default:
					args[i] = val
				}
			} else {
				args[i] = val
			}
		}

		if _, err := stmt.Exec(args...); err != nil {
			continue
		}
	}
	return tx.Commit()
}


----- C:\Dev\KARASHI\mappers\mappers.go -----
// File: mappers/mappers.go (修正版)
package mappers

import (
	"database/sql"
	"karashi/db"
	"karashi/model"
	"karashi/units"
	"strconv"
)

// MapProductMasterToTransactionは、ProductMasterの情報をTransactionRecordにマッピングします。
func MapProductMasterToTransaction(ar *model.TransactionRecord, master *model.ProductMaster) {
	ar.YjCode = master.YjCode
	ar.ProductName = master.ProductName
	ar.KanaName = master.KanaName
	ar.PackageForm = master.PackageSpec
	ar.MakerName = master.MakerName
	ar.YjPackUnitQty = master.YjPackUnitQty
	ar.JanPackUnitQty = master.JanPackUnitQty
	ar.FlagPoison = master.FlagPoison
	ar.FlagDeleterious = master.FlagDeleterious
	ar.FlagNarcotic = master.FlagNarcotic
	ar.FlagPsychotropic = master.FlagPsychotropic
	ar.FlagStimulant = master.FlagStimulant
	ar.FlagStimulantRaw = master.FlagStimulantRaw
	ar.JanPackInnerQty = master.JanPackInnerQty

	yjUnitName := units.ResolveName(master.YjUnitName)
	janUnitCode := strconv.Itoa(master.JanUnitCode)
	var janUnitName string
	if janUnitCode == "0" || janUnitCode == "" {
		janUnitName = yjUnitName
	} else {
		janUnitName = units.ResolveName(janUnitCode)
	}
	ar.JanUnitName = janUnitName
	ar.YjUnitName = yjUnitName
	ar.JanUnitCode = janUnitCode

	// ProductMasterからJCShms相当の構造体を作成して関数を呼び出す
	tempJcshms := model.JCShms{
		JC037: master.PackageSpec,
		JC039: master.YjUnitName,
		JC044: master.YjPackUnitQty,
		JA006: sql.NullFloat64{Float64: master.JanPackInnerQty, Valid: true},
		JA008: sql.NullFloat64{Float64: master.JanPackUnitQty, Valid: true},
		JA007: sql.NullString{String: strconv.Itoa(master.JanUnitCode), Valid: true},
	}
	ar.PackageSpec = units.FormatPackageSpec(&tempJcshms)
}

// MapJcshmsToTransactionは、JCShmsの情報をTransactionRecordにマッピングします。
func MapJcshmsToTransaction(ar *model.TransactionRecord, jcshms *model.JCShms) {
	ar.ProductName = jcshms.JC018
	ar.KanaName = jcshms.JC022
	ar.PackageForm = jcshms.JC037
	ar.MakerName = jcshms.JC030
	ar.YjPackUnitQty = jcshms.JC044
	ar.JanPackInnerQty = jcshms.JA006.Float64
	ar.JanPackUnitQty = jcshms.JA008.Float64
	ar.FlagPoison = jcshms.JC061
	ar.FlagDeleterious = jcshms.JC062
	ar.FlagNarcotic = jcshms.JC063
	ar.FlagPsychotropic = jcshms.JC064
	ar.FlagStimulant = jcshms.JC065
	ar.FlagStimulantRaw = jcshms.JC066

	yjUnitName := units.ResolveName(jcshms.JC039)
	janUnitCode := jcshms.JA007.String
	var janUnitName string
	if janUnitCode == "0" || janUnitCode == "" {
		janUnitName = yjUnitName
	} else {
		janUnitName = units.ResolveName(janUnitCode)
	}
	ar.JanUnitName = janUnitName
	ar.YjUnitName = yjUnitName
	ar.JanUnitCode = janUnitCode

	// 新しい共通関数を呼び出して包装表記を生成
	ar.PackageSpec = units.FormatPackageSpec(jcshms)
}

// CreateMasterFromJcshmsInTxは、既存のトランザクション内でJCSHMSからマスターを作成します。
func CreateMasterFromJcshmsInTx(tx *sql.Tx, jan, yj string, jcshms *model.JCShms) error {
	var nhiPrice float64
	if jcshms.JC044 > 0 {
		nhiPrice = jcshms.JC050 / jcshms.JC044
	}
	masterInput := model.ProductMasterInput{
		ProductCode:      jan,
		YjCode:           yj,
		Origin:           "JCSHMS",
		ProductName:      jcshms.JC018,
		KanaName:         jcshms.JC022,
		MakerName:        jcshms.JC030,
		PackageSpec:      jcshms.JC037,
		YjUnitName:       jcshms.JC039,
		YjPackUnitQty:    jcshms.JC044,
		FlagPoison:       jcshms.JC061,
		FlagDeleterious:  jcshms.JC062,
		FlagNarcotic:     jcshms.JC063,
		FlagPsychotropic: jcshms.JC064,
		FlagStimulant:    jcshms.JC065,
		FlagStimulantRaw: jcshms.JC066,
		JanPackInnerQty:  jcshms.JA006.Float64,
		JanPackUnitQty:   jcshms.JA008.Float64,
		NhiPrice:         nhiPrice,
	}

	if jcshms.JA007.Valid {
		if val, err := strconv.Atoi(jcshms.JA007.String); err == nil {
			masterInput.JanUnitCode = val
		}
	}

	return db.CreateProductMasterInTx(tx, masterInput)
}


----- C:\Dev\KARASHI\model\types.go -----
// File: model/types.go (修正版)
package model

import "database/sql"

type JCShms struct {
	JC009 string
	JC018 string
	JC022 string
	JC030 string
	JC037 string
	JC039 string
	JC044 float64
	JC050 float64
	JC061 int
	JC062 int
	JC063 int
	JC064 int
	JC065 int
	JC066 int
	JA006 sql.NullFloat64
	JA007 sql.NullString
	JA008 sql.NullFloat64
}

type TransactionRecord struct {
	ID               int            `json:"id"`
	TransactionDate  string         `json:"transactionDate"`
	ClientCode       string         `json:"clientCode"`
	ReceiptNumber    string         `json:"receiptNumber"`
	LineNumber       string         `json:"lineNumber"`
	Flag             int            `json:"flag"`
	JanCode          string         `json:"janCode"`
	YjCode           string         `json:"yjCode"`
	ProductName      string         `json:"productName"`
	KanaName         string         `json:"kanaName"`
	PackageForm      string         `json:"packageForm"`
	PackageSpec      string         `json:"packageSpec"`
	MakerName        string         `json:"makerName"`
	DatQuantity      float64        `json:"datQuantity"`
	JanPackInnerQty  float64        `json:"janPackInnerQty"`
	JanQuantity      float64        `json:"janQuantity"`
	JanPackUnitQty   float64        `json:"janPackUnitQty"`
	JanUnitName      string         `json:"janUnitName"`
	JanUnitCode      string         `json:"janUnitCode"`
	YjQuantity       float64        `json:"yjQuantity"`
	YjPackUnitQty    float64        `json:"yjPackUnitQty"`
	YjUnitName       string         `json:"yjUnitName"`
	UnitPrice        float64        `json:"unitPrice"`
	Subtotal         float64        `json:"subtotal"`
	TaxAmount        float64        `json:"taxAmount"`
	TaxRate          float64        `json:"taxRate"`
	ExpiryDate       string         `json:"expiryDate"`
	LotNumber        string         `json:"lotNumber"`
	FlagPoison       int            `json:"flagPoison"`
	FlagDeleterious  int            `json:"flagDeleterious"`
	FlagNarcotic     int            `json:"flagNarcotic"`
	FlagPsychotropic int            `json:"flagPsychotropic"`
	FlagStimulant    int            `json:"flagStimulant"`
	FlagStimulantRaw int            `json:"flagStimulantRaw"`
	ProcessFlagMA    string         `json:"processFlagMA"`
	ProcessingStatus sql.NullString `json:"processingStatus"`
}

type ProductMaster struct {
	ProductCode      string  `json:"productCode"`
	YjCode           string  `json:"yjCode"`
	ProductName      string  `json:"productName"`
	Origin           string  `json:"origin"`
	KanaName         string  `json:"kanaName"`
	MakerName        string  `json:"makerName"`
	PackageSpec      string  `json:"packageSpec"`
	YjUnitName       string  `json:"yjUnitName"`
	YjPackUnitQty    float64 `json:"yjPackUnitQty"`
	FlagPoison       int     `json:"flagPoison"`
	FlagDeleterious  int     `json:"flagDeleterious"`
	FlagNarcotic     int     `json:"flagNarcotic"`
	FlagPsychotropic int     `json:"flagPsychotropic"`
	FlagStimulant    int     `json:"flagStimulant"`
	FlagStimulantRaw int     `json:"flagStimulantRaw"`
	JanPackInnerQty  float64 `json:"janPackInnerQty"`
	JanUnitCode      int     `json:"janUnitCode"`
	JanPackUnitQty   float64 `json:"janPackUnitQty"`
	JanUnitName      string  `json:"janUnitName"` // ★★★ この行を追加 ★★★
	ReorderPoint     float64 `json:"reorderPoint"`
	NhiPrice         float64 `json:"nhiPrice"`
}

type ProductMasterInput struct {
	ProductCode      string  `json:"productCode"`
	YjCode           string  `json:"yjCode"`
	ProductName      string  `json:"productName"`
	Origin           string  `json:"origin"`
	KanaName         string  `json:"kanaName"`
	MakerName        string  `json:"makerName"`
	PackageSpec      string  `json:"packageSpec"`
	YjUnitName       string  `json:"yjUnitName"`
	YjPackUnitQty    float64 `json:"yjPackUnitQty"`
	FlagPoison       int     `json:"flagPoison"`
	FlagDeleterious  int     `json:"flagDeleterious"`
	FlagNarcotic     int     `json:"flagNarcotic"`
	FlagPsychotropic int     `json:"flagPsychotropic"`
	FlagStimulant    int     `json:"flagStimulant"`
	FlagStimulantRaw int     `json:"flagStimulantRaw"`
	JanPackInnerQty  float64 `json:"janPackInnerQty"`
	JanUnitCode      int     `json:"janUnitCode"`
	JanPackUnitQty   float64 `json:"janPackUnitQty"`
	JanUnitName      string  `json:"janUnitName"` // ★★★ この行を追加 ★★★
	ReorderPoint     float64 `json:"reorderPoint"`
	NhiPrice         float64 `json:"nhiPrice"`
}

type ProductMasterView struct {
	ProductMaster
	FormattedPackageSpec string `json:"formattedPackageSpec"`
}

// ★★★ 得意先マスターの1行を表す構造体を追加 ★★★
type Client struct {
	Code string `json:"code"`
	Name string `json:"name"`
}


----- C:\Dev\KARASHI\model\unified.go -----
package model

// UnifiedInputRecordは、すべての入力ソース（DAT,USAGE,INV,IOD）の
// 全項目を網羅したスーパーセットとなる構造体です。
// 各パーサーはこの構造体を生成し、中央処理関数に渡します。
type UnifiedInputRecord struct {
	// --- 伝票・日付情報 ---
	Date          string `json:"date"`
	ClientCode    string `json:"clientCode"`
	ReceiptNumber string `json:"receiptNumber"`
	LineNumber    string `json:"lineNumber"`
	Flag          int    `json:"flag"`
	ExpiryDate    string `json:"expiryDate"` // ← float64 から string に変更
	LotNumber     string `json:"lotNumber"`

	// --- 薬品コード・名称 ---
	JanCode     string `json:"janCode"`
	YjCode      string `json:"yjCode"`
	ProductName string `json:"productName"`
	KanaName    string `json:"kanaName"`
	PackageSpec string `json:"packageSpec"`
	MakerName   string `json:"makerName"`

	// --- 数量 ---
	DatQuantity     float64 `json:"datQuantity"`
	JanPackInnerQty float64 `json:"janPackInnerQty"` // ✨ この行を追加
	JanQuantity     float64 `json:"janQuantity"`
	JanPackUnitQty  float64 `json:"janPackUnitQty"`
	YjQuantity      float64 `json:"yjQuantity"`
	YjPackUnitQty   float64 `json:"yjPackUnitQty"`

	// --- 単位 ---
	JanUnitName string `json:"janUnitName"`
	JanUnitCode string `json:"janUnitCode"`
	YjUnitName  string `json:"yjUnitName"`

	// --- 金額 ---
	UnitPrice float64 `json:"unitPrice"`
	Subtotal  float64 `json:"subtotal"`
	TaxAmount float64 `json:"taxAmount"`
	TaxRate   float64 `json:"taxRate"`

	// --- 薬事区分 ---
	FlagPoison       int `json:"flagPoison"`
	FlagDeleterious  int `json:"flagDeleterious"`
	FlagNarcotic     int `json:"flagNarcotic"`
	FlagPsychotropic int `json:"flagPsychotropic"`
	FlagStimulant    int `json:"flagStimulant"`
	FlagStimulantRaw int `json:"flagStimulantRaw"`

	// --- 処理結果フラグ ---
	ProcessFlagMA string `json:"processFlagMA"`
}


----- C:\Dev\KARASHI\static\css\styles.css -----
/* File: static/css/styles.css */

/* 必要最小限の白黒レイアウト用CSS */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}
body {
    font-family: sans-serif;
    background-color: #ffffff;
    padding: 10px;
}
table {
    border-collapse: collapse;
    width: 100%;
    font-size: 11pt;
    border: none;
}
th, td {
    border: 1px solid #000000;
    padding: 4px 6px;
    text-align: center;
    vertical-align: top;
}
th {
    font-weight: bold;
}
.left { text-align: left; }
.right { text-align: right; }
.center { text-align: center; }
.hidden { display: none !important; }

/* --- ページ構成 --- */
header {
    display: flex;
    align-items: center;
    gap: 10px;
    padding-bottom: 10px;
    border-bottom: 1px solid #000000;
    margin-bottom: 10px;
}
.btn {
    font-size: 14px;
    padding: 8px 16px;
    background-color: #ffffff;
    border: 1px solid #000000;
    cursor: pointer;
}
.btn:hover {
    background-color: #f0f0f0;
}
.table-container {
    overflow-x: auto;
    margin-bottom: 20px;
}

/* --- 入庫出庫画面専用 --- */
.in-out-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 20px;
}
.in-out-header h1 {
    font-size: 24px;
}
.section {
    margin-bottom: 20px;
}
.section h2 {
    font-size: 18px;
    margin-bottom: 10px;
}
.controller-table select, .controller-table input {
    width: 100%;
    border: 1px solid #000000;
    padding: 4px;
    font-size: 11pt;
    background-color: #fff;
}

/* --- モーダル --- */
.modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.6);
    display: flex;
    align-items: center;
    justify-content: center;
}
.modal-content {
    background-color: #ffffff;
    border: 1px solid #000000;
    padding: 20px;
    width: 80%;
    max-height: 90vh;
    display: flex;
    flex-direction: column;
}
.modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
}
.modal-header h2 {
    font-size: 20px;
}
.modal-body {
    overflow-y: auto;
}
.close-button {
    font-size: 24px;
    border: none;
    background: none;
    cursor: pointer;
}

----- C:\Dev\KARASHI\static\css\table_layout.css -----
/* File: static/css/table_layout.css */

/* --- テーブル専用のレイアウトスタイル --- */
.data-table {
    border-collapse: collapse;
    width: 100%;
    min-width: 1235px; /* Googleスプレッドシートのピクセル幅合計 */
    table-layout: fixed;
    border: 1px solid #ccc; /* 枠線の色を少し柔らかくします */
}
.data-table th,
.data-table td {
    border: 1px solid #ccc; /* 枠線の色を少し柔らかくします */
    background-color: #ffffff;
    text-align: left;
    font-family: 'docs-sans-serif', Arial;
    font-size: 11pt;
    vertical-align: middle; /* topから変更 */
    padding: 2px; /* パディングを少し狭くする */
    white-space: normal;
    word-break: break-all;
}
.data-table thead td {
    background-color: #f0f0f0; /* ★背景色を薄いグレーに変更 */
    text-align: center;
    font-weight: bold;
    color: #000000; /* ★文字色を黒に変更 */
    padding: 4px 6px; /* パディングを調整 */
    white-space: nowrap;
}


.data-table td input[type="text"],
.data-table td input[type="date"],
.data-table td select {
    width: 100%;
    border: 1px solid #999;
    padding: 4px;
    font-size: 11pt;
    box-sizing: border-box;
    background-color: #fff;
}

.data-table td button {
    padding: 4px 8px;
    background-color: #f0f0f0;
    border: 1px solid #000;
    cursor: pointer;
    font-size: 10pt;
    width: 100%; /* ボタンも幅100%に設定 */
    box-sizing: border-box; /* パディングとボーダーを幅に含める */
}

.data-table td.center { text-align: center; }
.data-table td.right { text-align: right; }

.data-table tbody tr:nth-child(2n-1) td {
    background-color: #ffffff;
}

.data-table tbody tr:nth-child(2n) td {
    background-color: #f9f9f9;
}

----- C:\Dev\KARASHI\static\js\app.js -----
// File: static/js/app.js
import { initDatUpload } from './dat.js';
import { initUsageUpload } from './usage.js';
import { initInOut } from './inout.js';

document.addEventListener('DOMContentLoaded', () => {
  // 各モジュールの初期化
  initDatUpload();
  initUsageUpload();
  initInOut();

  // ビュー切り替え
  const uploadView = document.getElementById('upload-view');
  const inOutView = document.getElementById('in-out-view');
  document.getElementById('uploadViewBtn').addEventListener('click', () => {
    uploadView.classList.remove('hidden');
    inOutView.classList.add('hidden');
  });
  document.getElementById('inOutViewBtn').addEventListener('click', () => {
    inOutView.classList.remove('hidden');
    uploadView.classList.add('hidden');
  });

  // 初期ビュー
  uploadView.classList.remove('hidden');
  inOutView.classList.add('hidden');
});

----- C:\Dev\KARASHI\static\js\common_table.js -----
// File: static/js/common_table.js (修正版)

/**
 * アップロード結果表示用テーブルの HTML を生成
 * @param {string} tableId テーブル要素に付与する ID
 * @returns {string} テーブル HTML
 */
export function createUploadTableHTML(tableId) {
  const colWidths = [
    "5.83%", "2.91%", "9.15%", "13.77%", "13.77%",
    "2.91%", "5.34%", "7.69%", "5.34%", "7.21%",
    "5.91%", "7.21%", "7.21%", "5.75%"
  ];
  const colgroup = `<colgroup>${
    colWidths.map(w => `<col style="width:${w};">`).join("")
  }</colgroup>`;
  const header = `
    <thead>
      <tr>
        <th rowspan="2">日付</th><th rowspan="2">種別</th><th>YJ</th><th colspan="2">製品名</th>
        <th rowspan="2">個数</th><th>JAN数量</th><th>JAN包装数</th><th>JAN単位</th>
        <th>単価</th><th>税額</th><th>期限</th><th>ロット</th><th>MA</th>
      </tr>
      <tr>
        <th>JAN</th><th>包装</th><th>メーカー</th><th>YJ数量</th>
        <th>YJ包装数</th><th>YJ単位</th><th>金額</th><th>税率</th>
        <th>得意先</th><th>伝票番号</th><th>行</th>
      </tr>
    </thead>
  `;
  return `<table id="${tableId}" class="data-table">${colgroup}${header}<tbody>
    <tr><td colspan="14">ファイルを選択してください。</td></tr>
  </tbody></table>`;
}

/**
 * アップロード結果レコードをテーブルに描画
 * @param {string} tableId 対象テーブルの ID
 * @param {Array<object>} records サーバーから返却されたレコード配列
 */
export function renderUploadTableRows(tableId, records) {
  const tbody = document.querySelector(`#${tableId} tbody`);
  if (!records || records.length === 0) {
    tbody.innerHTML = `<tr><td colspan="14">対象データがありません。</td></tr>`;
    return;
  }
  const flagMap = {1: "納", 2: "返", 3: "処"};
  let html = "";
  records.forEach(rec => {
    html += `
      <tr>
        <td rowspan="2">${rec.transactionDate || ""}</td>
        <td rowspan="2">${flagMap[rec.flag] || ""}</td>
        <td>${rec.yjCode || ""}</td>
        <td class="left" colspan="2">${rec.productName || ""}</td>
        <td class="right" rowspan="2">${rec.datQuantity?.toFixed(2) || ""}</td>
        <td class="right">${rec.janQuantity?.toFixed(2) || ""}</td>
        <td class="right">${rec.janPackUnitQty || ""}</td>
        
        <td>${rec.janUnitName || ""}</td>
        <td class="right">${rec.unitPrice?.toFixed(2) || ""}</td>
        <td class="right">${rec.taxAmount?.toFixed(2) || ""}</td>
        <td>${rec.expiryDate || ""}</td>
        <td class="left">${rec.lotNumber || ""}</td>
        <td class="left">${rec.processFlagMA || ""}</td>
      </tr>
      <tr>
        <td>${rec.janCode || ""}</td>
        <td class="left">${rec.packageSpec || ""}</td>
        <td class="left">${rec.makerName || ""}</td>
        <td class="right">${rec.yjQuantity?.toFixed(2) || ""}</td>
        <td class="right">${rec.yjPackUnitQty || ""}</td>
        <td>${rec.yjUnitName || ""}</td>
        <td class="right">${rec.subtotal?.toFixed(2) || ""}</td>
        <td class="right">${rec.taxRate != null ? (rec.taxRate * 100).toFixed(0) + "%" : ""}</td>
        <td class="left">${rec.clientCode || ""}</td>
        <td class="left">${rec.receiptNumber || ""}</td>
        <td class="right">${rec.lineNumber || ""}</td>
      </tr>
    `;
  });
  tbody.innerHTML = html;
}

export function setupDateDropdown(inputEl) {
  if (!inputEl) return;
  inputEl.value = new Date().toISOString().slice(0, 10);
}

/**
 * APIから得意先リストを取得してプルダウンに設定
 * @param {HTMLSelectElement} selectEl
 */
export async function setupClientDropdown(selectEl) {
  if (!selectEl) return;
  
  // 既存の選択肢をクリア（先頭の「選択してください」などは残す）
  const preservedOptions = Array.from(selectEl.querySelectorAll('option[value=""], option[value="--new--"]'));
  selectEl.innerHTML = '';
  preservedOptions.forEach(opt => selectEl.appendChild(opt));

  try {
    const res = await fetch('/api/clients');
    if (!res.ok) throw new Error('Failed to fetch clients');
    const clients = await res.json();

    if (clients) {
      clients.forEach(c => {
        const opt = document.createElement('option');
        opt.value = c.code;
        opt.textContent = `${c.code}:${c.name}`;
        selectEl.appendChild(opt);
      });
    }
  } catch (err) {
    console.error("得意先リストの取得に失敗:", err);
  }
}

----- C:\Dev\KARASHI\static\js\dat.js -----
// File: static/js/dat.js

import {
  createUploadTableHTML,
  renderUploadTableRows
} from './common_table.js';

export function initDatUpload() {
  const btn       = document.getElementById('datBtn');
  const input     = document.getElementById('datFileInput');
  const container = document.getElementById('upload-output-container');

  container.innerHTML = createUploadTableHTML('upload-output-table');

  btn.addEventListener('click', () => {
    container.innerHTML = createUploadTableHTML('upload-output-table');
    input.click();
  });

  input.addEventListener('change', async e => {
    if (!e.target.files.length) return;
    const tbody = document.querySelector('#upload-output-table tbody');
    tbody.innerHTML =
      `<tr><td colspan="14" style="text-align:center;">アップロード処理中...</td></tr>`;
    try {
      const formData = new FormData();
      for (const f of e.target.files) formData.append('file', f);
      const res = await fetch('/api/dat/upload', { method: 'POST', body: formData });
      if (!res.ok) throw new Error(res.status);
      const data = await res.json();
      renderUploadTableRows('upload-output-table', data.records);
    } catch (err) {
      tbody.innerHTML =
        `<tr><td colspan="14" style="color:red; text-align:center;">
           処理失敗: ${err.message}
         </td></tr>`;
    }
  });
}

----- C:\Dev\KARASHI\static\js\inout_details_table.js -----
// File: static/js/inout_details_table.js (Final Version)
import { initModal, showModal } from './inout_modal.js';

const detailsTableBody = document.querySelector('#details-table tbody');
const addRowBtn = document.getElementById('addRowBtn');
let targetRow = null;

/**
 * Calculates totals for a given row.
 * @param {HTMLTableRowElement} firstRow - The first row of the entry.
 */
function calculateRowTotals(firstRow) {
    if (!firstRow) return;
    const secondRow = firstRow.nextElementSibling;

    const quantity = parseFloat(firstRow.cells[5].querySelector('input').value) || 0;
    const unitPrice = parseFloat(firstRow.cells[8].querySelector('input').value) || 0;
    const taxRate = parseFloat(document.getElementById('in-out-taxrate').value) || 0;
    
    const janPackInnerQty = parseFloat(firstRow.dataset.janPackInnerQty) || 0;
    const yjQuantity = quantity * janPackInnerQty;
    secondRow.cells[3].textContent = yjQuantity.toFixed(2);

    const subtotal = quantity * unitPrice;
    const taxAmount = Math.floor(subtotal * (taxRate / 100));

    secondRow.cells[6].textContent = subtotal.toFixed(0); // Amount cell
    firstRow.cells[9].textContent = taxAmount.toFixed(0);  // Tax cell
}

/**
 * Handles product selection from the modal.
 * @param {object} product - The selected product data.
 */
function handleProductSelection(product) {
    if (!targetRow) return;
    const firstRow = targetRow;
    const secondRow = targetRow.nextElementSibling;

    // --- Store all necessary master data in the row's dataset ---
    firstRow.dataset.janPackInnerQty = product.janPackInnerQty || '0';
    firstRow.dataset.kanaName = product.kanaName || '';
    firstRow.dataset.packageForm = product.packageSpec || '';
    firstRow.dataset.flagPoison = product.flagPoison || '0';
    firstRow.dataset.flagDeleterious = product.flagDeleterious || '0';
    firstRow.dataset.flagNarcotic = product.flagNarcotic || '0';
    firstRow.dataset.flagPsychotropic = product.flagPsychotropic || '0';
    firstRow.dataset.flagStimulant = product.flagStimulant || '0';
    firstRow.dataset.flagStimulantRaw = product.flagStimulantRaw || '0';

    // --- Populate visible cells ---
    firstRow.cells[2].textContent = product.yjCode || '';
    firstRow.cells[3].textContent = product.productName || '';
    firstRow.cells[6].textContent = product.janPackUnitQty || '';
    firstRow.cells[7].textContent = product.janUnitName || '';
    firstRow.cells[8].querySelector('input').value = product.nhiPrice ? product.nhiPrice.toFixed(2) : '0.00';

    secondRow.cells[0].textContent = product.productCode || '';
    secondRow.cells[1].textContent = product.formattedPackageSpec || '';
    secondRow.cells[2].textContent = product.makerName || '';
    secondRow.cells[4].textContent = product.yjPackUnitQty || '';
    secondRow.cells[5].textContent = product.yjUnitName || '';
    
    calculateRowTotals(firstRow);
    targetRow = null;
}

/**
 * Adds a new empty row to the table.
 */
function addRow() {
  const newRowsHTML = `
    <tr>
      <td rowspan="2"></td>
      <td rowspan="2"></td>
      <td></td>
      <td colspan="2" class="product-name-cell"></td>
      <td rowspan="2"></td>
      <td><input type="text" class="recalc-trigger jan-quantity-input"></td>
      <td></td>
      <td></td>
      <td><input type="text" class="recalc-trigger unit-price-input"></td>
      <td></td>
      <td><input type="date"></td>
      <td><input type="text"></td>
      <td><button class="delete-row-btn">削除</button></td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
  `;
  detailsTableBody.insertAdjacentHTML('beforeend', newRowsHTML);
}

/**
 * Initializes the details table functionality.
 */
export function initDetailsTable() {
    if (!detailsTableBody || !addRowBtn) return;
    initModal(handleProductSelection);
    addRowBtn.addEventListener('click', addRow);
    
    detailsTableBody.addEventListener('click', (event) => {
        if (event.target.classList.contains('delete-row-btn')) {
            const firstRow = event.target.closest('tr');
            const secondRow = firstRow.nextElementSibling;
            firstRow.remove();
            if (secondRow) secondRow.remove();
            return;
        }
        const productNameCell = event.target.closest('.product-name-cell');
        if (productNameCell) {
            targetRow = productNameCell.closest('tr');
            showModal();
        }
    });

    detailsTableBody.addEventListener('input', (event) => {
        if (event.target.classList.contains('recalc-trigger')) {
            const firstRow = event.target.closest('tr');
            calculateRowTotals(firstRow);
        }
    });

    document.getElementById('in-out-taxrate').addEventListener('input', () => {
        const rows = detailsTableBody.querySelectorAll('tr:nth-child(odd)');
        rows.forEach(calculateRowTotals);
    });
}

/**
 * Gathers and returns data from the details table.
 * @returns {Array<object>}
 */
export function getDetailsData() {
    const records = [];
    const rows = detailsTableBody.querySelectorAll('tr:nth-child(odd)');
    rows.forEach((firstRow, index) => {
        const secondRow = firstRow.nextElementSibling;
        const productName = firstRow.cells[3].textContent.trim();
        if (!productName) return;

        const ds = firstRow.dataset; // Dataset for easy access

        const record = {
            lineNumber: (index + 1).toString(),
            yjCode: firstRow.cells[2].textContent,
            productName: productName,
            janQuantity: parseFloat(firstRow.cells[5].querySelector('input').value) || 0,
            janPackUnitQty: parseFloat(firstRow.cells[6].textContent) || 0,
            janUnitName: firstRow.cells[7].textContent,
            unitPrice: parseFloat(firstRow.cells[8].querySelector('input').value) || 0,
            expiryDate: firstRow.cells[10].querySelector('input').value.replace(/-/g, ''),
            lotNumber: firstRow.cells[11].querySelector('input').value,
            janCode: secondRow.cells[0].textContent,
            packageSpec: secondRow.cells[1].textContent,
            makerName: secondRow.cells[2].textContent,
            yjQuantity: parseFloat(secondRow.cells[3].textContent) || 0,
            yjPackUnitQty: parseFloat(secondRow.cells[4].textContent) || 0,
            yjUnitName: secondRow.cells[5].textContent,
            subtotal: parseFloat(secondRow.cells[6].textContent) || 0,
            taxAmount: parseFloat(firstRow.cells[9].textContent) || 0,
            // --- Add the new fields from the dataset ---
            datQuantity: 0, // Set to 0 as requested
            kanaName: ds.kanaName,
            packageForm: ds.packageForm,
            flagPoison: parseInt(ds.flagPoison, 10) || 0,
            flagDeleterious: parseInt(ds.flagDeleterious, 10) || 0,
            flagNarcotic: parseInt(ds.flagNarcotic, 10) || 0,
            flagPsychotropic: parseInt(ds.flagPsychotropic, 10) || 0,
            flagStimulant: parseInt(ds.flagStimulant, 10) || 0,
            flagStimulantRaw: parseInt(ds.flagStimulantRaw, 10) || 0,
        };
        records.push(record);
    });
    return records;
}

/**
 * Clears the details table.
 */
export function clearDetailsTable() {
    detailsTableBody.innerHTML = '';
}

/**
 * Populates the details table with loaded data.
 * @param {Array<object>} records - The transaction records to display.
 */
export function populateDetailsTable(records) {
    clearDetailsTable();
    let newHTML = '';

    records.forEach(rec => {
        const expiryDateFormatted = rec.expiryDate ? `${rec.expiryDate.slice(0, 4)}-${rec.expiryDate.slice(4, 6)}-${rec.expiryDate.slice(6, 8)}` : '';
        const flagMap = {1: "入庫", 2: "出庫"};

        // Recreate the two-row structure for each record, including the data-* attributes
        newHTML += `
            <tr 
              data-jan-pack-inner-qty="${rec.janPackInnerQty || 0}"
              data-kana-name="${rec.kanaName || ''}"
              data-package-form="${rec.packageForm || ''}"
              data-flag-poison="${rec.flagPoison || 0}"
              data-flag-deleterious="${rec.flagDeleterious || 0}"
              data-flag-narcotic="${rec.flagNarcotic || 0}"
              data-flag-psychotropic="${rec.flagPsychotropic || 0}"
              data-flag-stimulant="${rec.flagStimulant || 0}"
              data-flag-stimulant-raw="${rec.flagStimulantRaw || 0}"
            >
                <td rowspan="2">${rec.transactionDate || ''}</td>
                <td rowspan="2">${flagMap[rec.flag] || ''}</td>
                <td>${rec.yjCode || ''}</td>
                <td colspan="2" class="product-name-cell">${rec.productName || ''}</td>
                <td rowspan="2">${rec.datQuantity?.toFixed(2) || ''}</td>
                <td><input type="text" class="recalc-trigger jan-quantity-input" value="${rec.janQuantity || 0}"></td>
                <td>${rec.janPackUnitQty || ''}</td>
                <td>${rec.janUnitName || ''}</td>
                <td><input type="text" class="recalc-trigger unit-price-input" value="${rec.unitPrice?.toFixed(2) || 0}"></td>
                <td>${rec.taxAmount || 0}</td>
                <td><input type="date" value="${expiryDateFormatted}"></td>
                <td><input type="text" value="${rec.lotNumber || ''}"></td>
                <td><button class="delete-row-btn">削除</button></td>
            </tr>
            <tr>
                <td>${rec.janCode || ''}</td>
                <td>${rec.packageSpec || ''}</td>
                <td>${rec.makerName || ''}</td>
                <td>${rec.yjQuantity?.toFixed(2) || 0}</td>
                <td>${rec.yjPackUnitQty || ''}</td>
                <td>${rec.yjUnitName || ''}</td>
                <td>${rec.subtotal || 0}</td>
                <td>${rec.taxRate != null ? (rec.taxRate * 100).toFixed(0) + "%" : ""}</td>
                <td>${rec.clientCode || ''}</td>
                <td>${rec.receiptNumber || ''}</td>
                <td>${rec.lineNumber || ''}</td>
            </tr>
        `;
    });

    detailsTableBody.innerHTML = newHTML;
}

----- C:\Dev\KARASHI\static\js\inout_header.js -----
// File: static/js/inout_header.js (Corrected)
import { setupDateDropdown, setupClientDropdown } from './common_table.js'; 

const NEW_ENTRY_VALUE = '--new--'; 

let clientSelect, receiptSelect, saveBtn, deleteBtn, headerDateInput, headerTypeSelect;
let newClientName = null; 

async function initializeClientDropdown() {
    clientSelect.innerHTML = `<option value="">選択してください</option>`;
    await setupClientDropdown(clientSelect);
    
    const newOption = document.createElement('option');
    newOption.value = NEW_ENTRY_VALUE; 
    newOption.textContent = '--- 新規作成 ---'; 
    clientSelect.appendChild(newOption);
} 

export async function initHeader(getDetailsData, clearDetailsTable, populateDetailsTable) {
    clientSelect = document.getElementById('in-out-client'); 
    receiptSelect = document.getElementById('in-out-receipt'); 
    saveBtn = document.getElementById('saveBtn');
    deleteBtn = document.getElementById('deleteBtn');
    headerDateInput = document.getElementById('in-out-date'); 
    headerTypeSelect = document.getElementById('in-out-type'); 

    if (!clientSelect || !receiptSelect || !saveBtn || !deleteBtn) return; 
    deleteBtn.disabled = true; 

    setupDateDropdown(headerDateInput);
    await initializeClientDropdown(); 
    receiptSelect.innerHTML = `
        <option value="">日付を選択してください</option>
        <option value="${NEW_ENTRY_VALUE}">--- 新規作成 ---</option>
    `; 

    headerDateInput.addEventListener('change', async () => {
        const date = headerDateInput.value.replace(/-/g, '');
        if (!date) return;

        try {
            const res = await fetch(`/api/receipts?date=${date}`);
            if (!res.ok) throw new Error('伝票の取得に失敗');
            const receiptNumbers = await res.json();
            
            receiptSelect.innerHTML = `
                <option value="">選択してください</option>
                <option value="${NEW_ENTRY_VALUE}">--- 新規作成 ---</option>
            `;

            if (receiptNumbers && receiptNumbers.length > 0) {
                receiptNumbers.forEach(num => {
                    const opt = document.createElement('option');
                    opt.value = num;
                    opt.textContent = num;
                    receiptSelect.appendChild(opt);
                });
            }
        } catch (err) {
            console.error(err);
            receiptSelect.innerHTML = `
                <option value="">選択してください</option>
                <option value="${NEW_ENTRY_VALUE}">--- 新規作成 ---</option>
            `;
        }
    }); 

    clientSelect.addEventListener('change', () => {
        const selectedValue = clientSelect.value;
        if (selectedValue === NEW_ENTRY_VALUE) {
            const name = prompt('新しい得意先名を入力してください:');
            if (name && name.trim()) {
                newClientName = name.trim();
                const opt = document.createElement('option');
                opt.value = `new:${newClientName}`;
                opt.textContent = `[新規] ${newClientName}`;
                opt.selected = true;
                clientSelect.appendChild(opt);
            } else {
                clientSelect.value = '';
            }
        } else if (!selectedValue.startsWith('new:')) {
            newClientName = null;
        }
    }); 

    receiptSelect.addEventListener('change', async () => {
        const selectedValue = receiptSelect.value;
        deleteBtn.disabled = (selectedValue === NEW_ENTRY_VALUE || selectedValue === "");

        if (selectedValue === NEW_ENTRY_VALUE || selectedValue === "") {
            clearDetailsTable();
        } else {
            try {
                const res = await fetch(`/api/transaction/${selectedValue}`); 
                if (!res.ok) throw new Error('明細の読込に失敗');
                const records = await res.json();
                populateDetailsTable(records);
            } catch (err) {
                console.error(err); 
                alert(err.message);
            }
        }
    }); 
    
    // ★★★ SAVE BUTTON LOGIC CORRECTED ★★★
    saveBtn.addEventListener('click', async () => {
        let clientCode = clientSelect.value;
        let clientNameToSave = '';
        let isNewClient = false;

        if (newClientName && clientCode.startsWith('new:')) {
            clientNameToSave = newClientName;
            isNewClient = true;
            clientCode = ''; // Clear the temporary code
        } else {
            if (!clientCode || clientCode === NEW_ENTRY_VALUE) {
                alert('得意先を選択または新規作成してください。');
                return;
            }
        }
        
        const records = getDetailsData();
        if (records.length === 0 && receiptSelect.value === NEW_ENTRY_VALUE) {
            alert('保存する明細データがありません。');
            return;
        }
        
        const payload = {
            isNewClient: isNewClient,
            clientCode: clientCode,
            clientName: clientNameToSave,
            transactionDate: headerDateInput.value.replace(/-/g, ''),
            transactionType: headerTypeSelect.value,
            records: records,
        };

        try {
            const res = await fetch('/api/inout/save', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload),
            });

            const resData = await res.json();
            if (!res.ok) {
                throw new Error(resData.message || `保存に失敗しました (HTTP ${res.status})`);
            }

            alert(`データを保存しました。\n伝票番号: ${resData.receiptNumber}`);
            
            clearDetailsTable();
            await initializeClientDropdown();
            receiptSelect.innerHTML = `
                <option value="">日付を選択してください</option>
                <option value="${NEW_ENTRY_VALUE}" selected>--- 新規作成 ---</option>
            `;
            newClientName = null;
            headerDateInput.dispatchEvent(new Event('change'));

        } catch (err) {
            console.error(err);
            alert(err.message);
        }
    });

    deleteBtn.addEventListener('click', async () => {
        const receiptNumber = receiptSelect.value;
        if (!receiptNumber || receiptNumber === NEW_ENTRY_VALUE) {
            alert("削除対象の伝票が選択されていません。");
            return;
        }

        if (!confirm(`伝票番号 [${receiptNumber}] を完全に削除します。よろしいですか？`)) {
            return; 
        }

        try {
            const res = await fetch(`/api/transaction/delete/${receiptNumber}`, {
                method: 'DELETE',
            });
            
            if (!res.ok) {
                const errData = await res.json(); 
                throw new Error(errData.message || '削除に失敗しました。');
            }

            alert(`伝票 [${receiptNumber}] を削除しました。`);
            
            clearDetailsTable();
            await initializeClientDropdown(); 
            receiptSelect.innerHTML = `
                <option value="">日付を選択してください</option>
                <option value="${NEW_ENTRY_VALUE}" selected>--- 新規作成 ---</option>
            `;
            newClientName = null; 
            deleteBtn.disabled = true;
            headerDateInput.dispatchEvent(new Event('change'));

        } catch(err) {
            console.error(err);
            alert(err.message); 
        }
    }); 

    headerDateInput.dispatchEvent(new Event('change'));
}

----- C:\Dev\KARASHI\static\js\inout_modal.js -----
// File: static/js/inout_modal.js

// --- プライベート変数 ---
let onProductSelectCallback = null;

// --- DOM要素の取得 ---
const modal = document.getElementById('search-modal'); 
const closeModalBtn = document.getElementById('closeModalBtn'); 
const searchInput = document.getElementById('product-search-input');
const searchBtn = document.getElementById('product-search-btn');
const searchResultsBody = document.querySelector('#search-results-table tbody'); 

/**
 * 検索結果テーブルでのクリックを処理（イベント委譲）
 * @param {Event} event
 */
function handleResultClick(event) {
  if (event.target && event.target.classList.contains('select-product-btn')) {
    const product = JSON.parse(event.target.dataset.product); 
    if (typeof onProductSelectCallback === 'function') { 
      onProductSelectCallback(product); 
    }
    modal.classList.add('hidden'); 
  }
}

/**
 * APIを叩いて製品を検索する
 */
async function performSearch() {
  const query = searchInput.value.trim(); 
  if (query.length < 2) { 
    alert('2文字以上入力してください。');
    return;
  }
  searchResultsBody.innerHTML = '<tr><td colspan="6" class="center">検索中...</td></tr>'; 
  try {
    const res = await fetch(`/api/products/search?q=${encodeURIComponent(query)}`); 
    if (!res.ok) throw new Error(`サーバーエラー: ${res.status}`); 
    const products = await res.json(); 
    renderSearchResults(products);
  } catch (err) {
    searchResultsBody.innerHTML = `<tr><td colspan="6" class="center" style="color:red;">${err.message}</td></tr>`; 
  }
}

/**
 * 検索結果をテーブルに描画する
 * @param {Array<object>} products
 */
function renderSearchResults(products) {
  if (!products || products.length === 0) { 
    searchResultsBody.innerHTML = '<tr><td colspan="6" class="center">該当する製品が見つかりません。</td></tr>'; 
    return; 
  }
  let html = '';
  products.forEach(p => {
    const productData = JSON.stringify(p);
    // ★★★ Goから送られてきた整形済み包装表記をそのまま使う ★★★
    html += `
      <tr>
        <td class="left">${p.productName || ''}</td>
        <td class="left">${p.makerName || ''}</td>
        <td class="left">${p.formattedPackageSpec}</td>
        <td>${p.yjCode || ''}</td>
        <td>${p.productCode || ''}</td>
        <td><button class="select-product-btn" data-product='${productData}'>選択</button></td>
      </tr>
    `; 
  });
  searchResultsBody.innerHTML = html;
}

/**
 * モーダルを初期化し、イベントリスナーを設定する
 * @param {function} onSelect - 製品選択時に実行されるコールバック関数
 */
export function initModal(onSelect) {
  if (!modal || !closeModalBtn || !searchInput || !searchBtn || !searchResultsBody) {
    console.error("薬品検索モーダルの必須要素が見つかりません。"); 
    return; 
  }
  onProductSelectCallback = onSelect;

  closeModalBtn.addEventListener('click', () => modal.classList.add('hidden'));
  searchBtn.addEventListener('click', performSearch); 
  searchInput.addEventListener('keypress', (e) => { 
    if (e.key === 'Enter') performSearch();
  });
  searchResultsBody.addEventListener('click', handleResultClick); 
}

/**
 * モーダルを表示する
 */
export function showModal() {
  if (modal) {
    modal.classList.remove('hidden');
    searchInput.focus();
    searchResultsBody.innerHTML = '<tr><td colspan="6">製品名を入力して検索してください。</td></tr>'; 
  }
}

----- C:\Dev\KARASHI\static\js\inout.js -----
// File: static/js/inout.js (Corrected)
import { initHeader } from './inout_header.js';
import { initDetailsTable, getDetailsData, clearDetailsTable, populateDetailsTable } from './inout_details_table.js';

/**
 * Initializes all In/Out screen functionality and correctly wires up dependencies.
 */
export async function initInOut() {
  // Initialize the details table module first.
  initDetailsTable();

  // Initialize the header module, passing it the functions it needs from the details module.
  await initHeader(getDetailsData, clearDetailsTable, populateDetailsTable);
}

----- C:\Dev\KARASHI\static\js\usage.js -----
// File: static/js/usage.js
import {
  createUploadTableHTML,
  renderUploadTableRows
} from './common_table.js';

export function initUsageUpload() {
  const btn       = document.getElementById('usageBtn');
  const input     = document.getElementById('usageFileInput');
  const container = document.getElementById('upload-output-container');

  container.innerHTML = createUploadTableHTML('upload-output-table');

  btn.addEventListener('click', () => {
    container.innerHTML = createUploadTableHTML('upload-output-table');
    input.click();
  });

  input.addEventListener('change', async e => {
    if (!e.target.files.length) return;
    const tbody = document.querySelector('#upload-output-table tbody');
    tbody.innerHTML = `<tr><td colspan="14" style="text-align:center;">アップロード処理中...</td></tr>`;

    try {
      const formData = new FormData();
      for (const f of e.target.files) formData.append('file', f);
      const res = await fetch('/api/usage/upload', { method: 'POST', body: formData });
      if (!res.ok) throw new Error(res.status);
      const data = await res.json();
      renderUploadTableRows('upload-output-table', data.records);
    } catch (err) {
      tbody.innerHTML =
        `<tr><td colspan="14" style="color:red; text-align:center;">
           処理失敗: ${err.message}
         </td></tr>`;
    }
  });
}

----- C:\Dev\KARASHI\static\index.html -----
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KARASHI</title>
    <link rel="stylesheet" href="/static/css/styles.css">
    <link rel="stylesheet" href="/static/css/table_layout.css">
</head>
<body>

    <header>
        <button id="uploadViewBtn" class="btn">伝票アップロード</button>
        <button id="inOutViewBtn" class="btn">入庫出庫</button>
    </header>

    <main>
        <div id="upload-view" class="hidden">
            <input type="file" id="datFileInput" multiple style="display:none;">
            <input type="file" id="usageFileInput" style="display:none;">
            <div class="table-container">
                <button id="datBtn" class="btn">納品・返品 (DAT) ファイル選択</button>
                <button id="usageBtn" class="btn">処方 (USAGE) ファイル選択</button>
            </div>
            <div id="upload-output-container" class="table-container">
                </div>
         </div>

        <div id="in-out-view">
            <div class="in-out-header">
                <h1>入庫出庫</h1>
            </div>

            <div class="section">
                <h2>表1: div2までの表</h2>
<table id="controller-table" class="data-table" cellspacing="0" cellpadding="0">
    <thead>
        <tr>
            <td class="center" style="width: 10%;">日付</td>
            <td class="center" style="width: 10%;">種別</td>
            <td style="width: 25%;"></td> <td class="center" style="width: 5%;">税率</td>
            <td class="center" style="width: 20%;">得意先</td>
            <td class="center" style="width: 20%;">伝票番号</td>
            <td class="center" style="width: 10%;">保存</td>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><input type="date" id="in-out-date"></td>
            <td><select id="in-out-type"><option>入庫</option><option>出庫</option></select></td>
            <td></td> <td><input type="text" id="in-out-taxrate" value="10"></td>
            <td><select id="in-out-client" style="width:100%;"></select></td>
            <td><select id="in-out-receipt" style="width:100%;"></select></td>
            <td style="display: flex; gap: 5px;">
                <button id="saveBtn" class="btn">保存</button>
                <button id="deleteBtn" class="btn">伝票削除</button>
            </td>
        </tr>
    </tbody>
</table>
            </div>

            <div class="section">
                <h2>表2: div3からの表</h2>
                <div id="details-table-container">
                    <table id="details-table" class="data-table" cellspacing="0" cellpadding="0">
                        <thead>
                            <tr>
                                <td rowspan="2" class="center">日付</td>
                                <td rowspan="2" class="center">種別</td>
                                <td class="center">YJ</td>
                                <td colspan="2" class="center">製品名</td>
                                <td rowspan="2" class="center">個数</td>
                                <td class="center">JAN数量</td>
                                <td class="center">JAN包装数量</td>
                                <td class="center">JAN単位</td>
                                <td class="center">単価</td>
                                <td class="center">税額</td>
                                <td class="center">期限</td>
                                <td class="center">ロット</td>
                                <td class="center"><button id="addRowBtn">追加ボタン</button></td>
                            </tr>
                            <tr>
                                <td class="center">JAN</td>
                                <td class="center">包装</td>
                                <td class="center">メーカー</td>
                                <td class="center">YJ数量</td>
                                <td class="center">YJ包装数量</td>
                                <td class="center">YJ単位</td>
                                <td class="center">金額</td>
                                <td class="center">税率</td>
                                <td class="center">得意先</td>
                                <td class="center">伝票番号</td>
                                <td class="center">行</td>
                            </tr>
                        </thead>
                        <tbody>
                            </tbody>
                    </table>
                </div>
            </div>

            <div id="search-modal" class="modal-overlay hidden">
    <div class="modal-content">
        <div class="modal-header">
             <h2>薬品検索</h2>
             <button id="closeModalBtn" class="close-button">&times;</button>
        </div>
        <div style="margin-bottom: 10px; display: flex; gap: 5px;">
            <input type="text" id="product-search-input" placeholder="製品名またはカナ名（2文字以上）" style="flex-grow: 1; padding: 5px;">
            <button id="product-search-btn" class="btn">検索</button>
        </div>
        <div class="modal-body" id="search-results-container">
            <table class="data-table" id="search-results-table">
                <thead>
                    <tr>
                        <th>製品名</th>
                        <th>メーカー</th>
                        <th>包装</th>
                        <th>YJコード</th>
                        <th>JANコード</th>
                        <th>選択</th> </tr>
                </thead>
                <tbody>
                    </tbody>
            </table>
        </div>
     </div>
</div>
        </div>
    </main>

    <script type="module" src="/static/js/app.js"></script>

</body>
</html>

----- C:\Dev\KARASHI\units\units.go -----
// File: units/units.go (修正版)
package units

import (
	"encoding/csv"
	"fmt"
	"io"
	"karashi/model"
	"os"

	"golang.org/x/text/encoding/japanese"
	"golang.org/x/text/transform"
)

var internalMap map[string]string
var reverseMap map[string]string

// ★★★ ここからが新しく追加・修正された部分 ★★★

// resolveInnerUnitはJA007のコードから内包装の単位を解決するヘルパー関数です。
// 0や空の場合は空文字を返します。
func resolveInnerUnit(unitCode string) string {
	if unitCode != "0" && unitCode != "" {
		return ResolveName(unitCode)
	}
	return ""
}

// FormatPackageSpecは、JCSHMSのデータから仕様通りの包装文字列を生成します。
func FormatPackageSpec(jcshms *model.JCShms) string {
	if jcshms == nil {
		return ""
	}

	yjUnitName := ResolveName(jcshms.JC039)
	pkg := fmt.Sprintf("%s %g%s", jcshms.JC037, jcshms.JC044, yjUnitName)

	if jcshms.JA006.Valid && jcshms.JA008.Valid && jcshms.JA008.Float64 != 0 {
		// 新しいヘルパー関数を呼び出して単位を取得
		innerUnit := resolveInnerUnit(jcshms.JA007.String)

		pkg += fmt.Sprintf(" (%g%s×%g%s)",
			jcshms.JA006.Float64,
			yjUnitName,
			jcshms.JA008.Float64,
			innerUnit,
		)
	}
	return pkg
}

// ★★★ ここまで ★★★

func LoadTANIFile(path string) (map[string]string, error) {
	file, err := os.Open(path)
	if err != nil {
		return nil, fmt.Errorf("LoadTANIFile: open %s: %w", path, err)
	}
	defer file.Close()

	decoder := japanese.ShiftJIS.NewDecoder()
	reader := csv.NewReader(transform.NewReader(file, decoder))
	reader.LazyQuotes = true
	reader.FieldsPerRecord = -1

	m := make(map[string]string)
	for {
		record, err := reader.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			return nil, fmt.Errorf("LoadTANIFile: read %s: %w", path, err)
		}
		if len(record) < 2 {
			continue
		}
		code := record[0]
		name := record[1]
		m[code] = name
	}
	internalMap = m

	reverseMap = make(map[string]string)
	for code, name := range internalMap {
		reverseMap[name] = code
	}

	return m, nil
}

func ResolveName(code string) string {
	if internalMap == nil {
		return code
	}
	if name, ok := internalMap[code]; ok {
		return name
	}
	return code
}

func ResolveCode(name string) string {
	if reverseMap == nil {
		return ""
	}
	if code, ok := reverseMap[name]; ok {
		return code
	}
	return ""
}


----- C:\Dev\KARASHI\usage\handler.go -----
// File: usage/handler.go
package usage

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"karashi/central"
	"karashi/db"
	"karashi/model"
	"log"
	"net/http"
)

func UploadUsageHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		if err := r.ParseMultipartForm(32 << 20); err != nil {
			http.Error(w, "File upload error: "+err.Error(), http.StatusBadRequest)
			return
		}
		defer r.MultipartForm.RemoveAll()

		var allParsed []model.UnifiedInputRecord
		for _, fh := range r.MultipartForm.File["file"] {
			f, _ := fh.Open()
			defer f.Close()
			recs, _ := ParseUsage(f)
			allParsed = append(allParsed, recs...)
		}
		filtered := removeUsageDuplicates(allParsed)

		if len(filtered) == 0 {
			w.Header().Set("Content-Type", "application/json; charset=utf-8")
			json.NewEncoder(w).Encode(map[string]interface{}{"records": []model.TransactionRecord{}})
			return
		}

		tx, err := conn.Begin()
		if err != nil {
			log.Printf("Failed to begin transaction for usage: %v", err)
			http.Error(w, "internal server error", http.StatusInternalServerError)
			return
		}
		defer tx.Rollback()

		// ✨ 修正点: tx を渡す
		finalRecords, err := central.ProcessUsageRecords(tx, conn, filtered)
		if err != nil {
			log.Printf("central.ProcessUsageRecords failed: %v", err)
			http.Error(w, "internal server error", http.StatusInternalServerError)
			return
		}

		minDate, maxDate := "99999999", "00000000"
		for _, rec := range filtered {
			if rec.Date < minDate {
				minDate = rec.Date
			}
			if rec.Date > maxDate {
				maxDate = rec.Date
			}
		}

		if err := db.DeleteUsageTransactionsInDateRange(tx, minDate, maxDate); err != nil {
			log.Printf("db.DeleteUsageTransactionsInDateRange error: %v", err)
			http.Error(w, "internal server error", http.StatusInternalServerError)
			return
		}

		if len(finalRecords) > 0 {
			if err := db.PersistTransactionRecordsInTx(tx, finalRecords); err != nil {
				log.Printf("PersistTransactionRecordsInTx error: %v", err)
				http.Error(w, "internal server error", http.StatusInternalServerError)
				return
			}
		}

		if err := tx.Commit(); err != nil {
			log.Printf("transaction commit error: %v", err)
			http.Error(w, "internal server error", http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		json.NewEncoder(w).Encode(map[string]interface{}{
			"records": finalRecords,
		})
	}
}

// removeUsageDuplicatesはUSAGE固有の重複排除ロジック
func removeUsageDuplicates(rs []model.UnifiedInputRecord) []model.UnifiedInputRecord {
	seen := make(map[string]struct{})
	var out []model.UnifiedInputRecord
	for _, r := range rs {
		key := fmt.Sprintf("%s|%s|%s|%s", r.Date, r.JanCode, r.YjCode, r.ProductName)
		if _, ok := seen[key]; ok {
			continue
		}
		seen[key] = struct{}{}
		out = append(out, r)
	}
	return out
}


----- C:\Dev\KARASHI\usage\parser.go -----
// File: usage/parser.go
package usage

import (
	"encoding/csv"
	"fmt"
	"io"
	"karashi/model"
	"strconv"

	"golang.org/x/text/encoding/japanese"
	"golang.org/x/text/transform"
)

// ParseUsageはUSAGE CSVを解析し、UnifiedInputRecordのスライスを返します。
func ParseUsage(r io.Reader) ([]model.UnifiedInputRecord, error) {
	reader := csv.NewReader(transform.NewReader(r, japanese.ShiftJIS.NewDecoder()))
	reader.FieldsPerRecord = -1

	var records []model.UnifiedInputRecord
	for {
		rec, err := reader.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			return nil, fmt.Errorf("csv read error: %w", err)
		}

		yjQty, _ := strconv.ParseFloat(rec[4], 64)

		unifiedRec := model.UnifiedInputRecord{
			Date:        rec[0],
			YjCode:      rec[1],
			JanCode:     rec[2],
			ProductName: rec[3],
			YjQuantity:  yjQty,
			YjUnitName:  rec[5],
		}
		records = append(records, unifiedRec)
	}
	return records, nil
}


----- C:\Dev\KARASHI\main.go -----
// File: main.go (完成版)
package main

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"karashi/dat"
	"karashi/db"
	"karashi/inout"  // ★ inoutパッケージをインポート
	"karashi/loader" // ★ modelパッケージをインポート
	"karashi/units"
	"karashi/usage"
	"log"
	"net/http"
	"os/exec"
	"runtime"
	"strings"

	_ "github.com/mattn/go-sqlite3"
)

func main() {
	conn, err := sql.Open("sqlite3", "yamato.db")
	if err != nil {
		log.Fatalf("db open error: %v", err)
	}
	defer conn.Close()

	if err := loader.InitDatabase(conn); err != nil {
		log.Fatalf("master init failed: %v", err)
	}
	if _, err := units.LoadTANIFile("SOU/TANI.CSV"); err != nil {
		log.Fatalf("tani init failed: %v", err)
	}
	log.Println("master init complete")

	mux := http.NewServeMux()

	// ★★★ ADD THE FOLLOWING HANDLER ★★★
	// Handles deletion of an entire transaction slip.
	mux.HandleFunc("/api/transaction/delete/", func(w http.ResponseWriter, r *http.Request) {
		if r.Method != http.MethodDelete {
			http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
			return
		}

		receiptNumber := strings.TrimPrefix(r.URL.Path, "/api/transaction/delete/")
		if receiptNumber == "" {
			http.Error(w, "Receipt number is required", http.StatusBadRequest)
			return
		}

		tx, err := conn.Begin()
		if err != nil {
			http.Error(w, "Failed to start transaction", http.StatusInternalServerError)
			return
		}
		defer tx.Rollback()

		if err := db.DeleteTransactionsByReceiptNumberInTx(tx, receiptNumber); err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}

		if err := tx.Commit(); err != nil {
			http.Error(w, "Failed to commit transaction", http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{"message": "Slip deleted successfully"})
	})

	// ★★★ ここから下を追記 ★★★

	// 日付を元に伝票番号リストを取得するAPI
	mux.HandleFunc("/api/receipts", func(w http.ResponseWriter, r *http.Request) {
		date := r.URL.Query().Get("date")
		if date == "" {
			http.Error(w, "Date parameter is required", http.StatusBadRequest)
			return
		}
		numbers, err := db.GetReceiptNumbersByDate(conn, date)
		if err != nil {
			http.Error(w, "Failed to get receipt numbers", http.StatusInternalServerError)
			return
		}
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(numbers)
	})

	// 伝票番号を元に明細リストを取得するAPI
	mux.HandleFunc("/api/transaction/", func(w http.ResponseWriter, r *http.Request) {
		receiptNumber := strings.TrimPrefix(r.URL.Path, "/api/transaction/")
		if receiptNumber == "" {
			http.Error(w, "Receipt number is required", http.StatusBadRequest)
			return
		}
		records, err := db.GetTransactionsByReceiptNumber(conn, receiptNumber)
		if err != nil {
			http.Error(w, "Failed to get transaction details", http.StatusInternalServerError)
			return
		}
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(records)
	})

	// ★★★ ここまで ★★★

	// ★★★ 得意先リストを返すAPIを追加 ★★★
	mux.HandleFunc("/api/clients", func(w http.ResponseWriter, r *http.Request) {
		clients, err := db.GetAllClients(conn)
		if err != nil {
			http.Error(w, "Failed to get clients", http.StatusInternalServerError)
			return
		}
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(clients)
	})

	// 薬品検索API
	mux.HandleFunc("/api/products/search", func(w http.ResponseWriter, r *http.Request) {
		query := r.URL.Query().Get("q")
		if len(query) < 2 {
			http.Error(w, "Query must be at least 2 characters", http.StatusBadRequest)
			return
		}
		results, err := db.SearchJcshmsByName(conn, query)
		if err != nil {
			http.Error(w, "Failed to search products", http.StatusInternalServerError)
			log.Printf("SearchJcshmsByName error: %v", err)
			return
		}
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(results)
	})

	// 各種アップロードと保存のハンドラ
	mux.Handle("/api/dat/upload", dat.UploadDatHandler(conn))
	mux.Handle("/api/usage/upload", usage.UploadUsageHandler(conn))
	mux.Handle("/api/inout/save", inout.SaveInOutHandler(conn)) // ★ この行が重要

	// 静的ファイルとルートハンドラ
	mux.Handle("/static/", http.StripPrefix("/static/", http.FileServer(http.Dir("./static"))))
	mux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		http.ServeFile(w, r, "./static/index.html")
	})

	port := ":8080"
	go openBrowser("http://localhost" + port)
	log.Printf("starting on %s", port)
	if err := http.ListenAndServe(port, mux); err != nil {
		log.Fatalf("server failed: %v", err)
	}
}

func openBrowser(url string) {
	var err error
	switch runtime.GOOS {
	case "linux":
		err = exec.Command("xdg-open", url).Start()
	case "windows":
		err = exec.Command("rundll32", "url.dll,FileProtocolHandler", url).Start()
	case "darwin":
		err = exec.Command("open", url).Start()
	default:
		err = fmt.Errorf("unsupported platform")
	}
	if err != nil {
		log.Printf("failed to open browser: %v", err)
	}
}


----- C:\Dev\KARASHI\schema.sql -----
-- File: schema.sql (修正版)

-- 得意先マスターテーブル
CREATE TABLE IF NOT EXISTS client_master (
  client_code TEXT PRIMARY KEY,
  client_name TEXT NOT NULL UNIQUE
);

-- 製品マスタ
CREATE TABLE IF NOT EXISTS product_master (
  product_code TEXT PRIMARY KEY, yj_code TEXT, product_name TEXT,  origin TEXT, kana_name TEXT, maker_name TEXT,
  package_spec TEXT, yj_unit_name TEXT, yj_pack_unit_qty REAL, flag_poison INTEGER, flag_deleterious INTEGER,
  flag_narcotic INTEGER, flag_psychotropic INTEGER, flag_stimulant INTEGER, flag_stimulant_raw INTEGER,
  jan_pack_inner_qty REAL, jan_unit_code INTEGER, jan_pack_unit_qty REAL,
  reorder_point REAL DEFAULT 0,
  nhi_price REAL DEFAULT 0
);

-- トランザクションレコード
CREATE TABLE IF NOT EXISTS transaction_records (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  transaction_date TEXT, client_code TEXT, receipt_number TEXT, line_number TEXT, flag INTEGER,
  jan_code TEXT, yj_code TEXT, product_name TEXT, kana_name TEXT,
  package_form TEXT,
  package_spec TEXT,
  maker_name TEXT,
  dat_quantity REAL,
  jan_pack_inner_qty REAL,
  jan_quantity REAL,
  jan_pack_unit_qty REAL, jan_unit_name TEXT, jan_unit_code TEXT,
  yj_quantity REAL, yj_pack_unit_qty REAL, yj_unit_name TEXT, unit_price REAL, subtotal REAL,
  tax_amount REAL, tax_rate REAL,
  expiry_date TEXT,
  lot_number TEXT,
  flag_poison INTEGER,
  flag_deleterious INTEGER, flag_narcotic INTEGER, flag_psychotropic INTEGER, flag_stimulant INTEGER,
  flag_stimulant_raw INTEGER, process_flag_ma TEXT,
  processing_status TEXT
);

-- JCSHMSマスタ
CREATE TABLE IF NOT EXISTS jcshms (
  JC000 TEXT, JC001 TEXT, JC002 TEXT, JC003 TEXT, JC004 TEXT, JC005 TEXT, JC006 TEXT, JC007 TEXT, JC008 TEXT, JC009 TEXT,
  JC010 TEXT, JC011 TEXT, JC012 TEXT, JC013 TEXT, JC014 TEXT, JC015 TEXT, JC016 TEXT, JC017 TEXT, JC018 TEXT, JC019 TEXT,
  JC020 TEXT, JC021 TEXT, JC022 TEXT, JC023 TEXT, JC024 TEXT, JC025 TEXT, JC026 TEXT, JC027 TEXT, JC028 TEXT, JC029 TEXT,
  JC030 TEXT, JC031 TEXT, JC032 TEXT, JC033 TEXT, JC034 TEXT, JC035 TEXT, JC036 TEXT, JC037 TEXT, JC038 TEXT, JC039 TEXT,
  JC040 TEXT, JC041 TEXT, JC042 TEXT, JC043 TEXT, JC044 REAL, JC045 TEXT, JC046 TEXT, JC047 TEXT, JC048 TEXT, JC049 TEXT,
  JC050 REAL, JC051 TEXT, JC052 TEXT, JC053 TEXT, JC054 TEXT, JC055 TEXT, JC056 TEXT, JC057 TEXT, JC058 TEXT, JC059 TEXT,
  JC060 TEXT, JC061 INTEGER, JC062 INTEGER, JC063 INTEGER, JC064 INTEGER, JC065 INTEGER, JC066 INTEGER, JC067 TEXT, JC068 TEXT, JC069 TEXT,
  JC070 TEXT, JC071 TEXT, JC072 TEXT, JC073 TEXT, JC074 TEXT, JC075 TEXT, JC076 TEXT, JC077 TEXT, JC078 TEXT, JC079 TEXT,
  JC080 TEXT, JC081 TEXT, JC082 TEXT, JC083 TEXT, JC084 TEXT, JC085 TEXT, JC086 TEXT, JC087 TEXT, JC088 TEXT, JC089 TEXT,
  JC090 TEXT, JC091 TEXT, JC092 TEXT, JC093 TEXT, JC094 TEXT, JC095 TEXT, JC096 TEXT, JC097 TEXT, JC098 TEXT, JC099 TEXT,
  JC100 TEXT, JC101 TEXT, JC102 TEXT, JC103 TEXT, JC104 TEXT, JC105 TEXT, JC106 TEXT, JC107 TEXT, JC108 TEXT, JC109 TEXT,
  JC110 TEXT, JC111 TEXT, JC112 TEXT, JC113 TEXT, JC114 TEXT, JC115 TEXT, JC116 TEXT, JC117 TEXT, JC118 TEXT, JC119 TEXT,
  JC120 TEXT, JC121 TEXT, JC122 TEXT, JC123 TEXT, JC124 TEXT,
  PRIMARY KEY(JC000)
);

-- JANCODEマスタ
CREATE TABLE IF NOT EXISTS jancode (
  JA000 TEXT, JA001 TEXT, JA002 TEXT, JA003 TEXT, JA004 TEXT, JA005 TEXT, JA006 REAL, JA007 TEXT, JA008 REAL, JA009 TEXT,
  JA010 TEXT, JA011 TEXT, JA012 TEXT, JA013 TEXT, JA014 TEXT, JA015 TEXT, JA016 TEXT, JA017 TEXT, JA018 TEXT, JA019 TEXT,
  JA020 TEXT, JA021 TEXT, JA022 TEXT, JA023 TEXT, JA024 TEXT, JA025 TEXT, JA026 TEXT, JA027 TEXT, JA028 TEXT, JA029 TEXT,
  PRIMARY KEY(JA001)
);

-- 自動採番シーケンス
CREATE TABLE IF NOT EXISTS code_sequences (
  name TEXT PRIMARY KEY,
  last_no INTEGER NOT NULL
);
INSERT OR IGNORE INTO code_sequences(name, last_no) VALUES ('MA2Y', 0);
INSERT OR IGNORE INTO code_sequences(name, last_no) VALUES ('CL', 0);

