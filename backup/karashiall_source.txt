----- C:\Dev\KARASHI\db\exist.go -----
// File: db/exist.go
package db

import (
	"database/sql"
)

// ExistsByJan checks if ma_master.MA000 (JANコード) exists.
func ExistsByJan(conn *sql.DB, jan string) (bool, error) {
	const q = `
SELECT 1
  FROM ma_master
 WHERE MA000 = ?
 LIMIT 1`
	var dummy int
	err := conn.QueryRow(q, jan).Scan(&dummy)
	if err == sql.ErrNoRows {
		return false, nil
	}
	return err == nil, err
}

// ExistsByYj checks if ma_master.MA009 (YJコード) exists.
func ExistsByYj(conn *sql.DB, yj string) (bool, error) {
	const q = `
SELECT 1
  FROM ma_master
 WHERE MA009 = ?
 LIMIT 1`
	var dummy int
	err := conn.QueryRow(q, yj).Scan(&dummy)
	if err == sql.ErrNoRows {
		return false, nil
	}
	return err == nil, err
}


----- C:\Dev\KARASHI\db\jcshms.go -----
// File: db/jcshms.go
package db

import (
	"database/sql"
	"errors"
	"log"
)

// JCShms は jcshms + jancode 結合結果。
// フィールド名を SQL列名そのままに揃えています。
type JCShms struct {
	JC000 string // 元JAN
	JC009 string // YJコード
	JC018 string // 品名
	JC022 string // 品名かな
	JC030 string // メーカー
	JC037 string // 包装ベース

	JC039 string // YJ単位名
	JC044 string // YJあたり数量

	JC061 int // 毒薬フラグ
	JC062 int // 劇薬フラグ
	JC063 int // 麻薬フラグ
	JC064 int // 向精神薬フラグ
	JC065 int // 覚せい剤フラグ
	JC066 int // 覚醒剤原料フラグ

	JA006 string // JAN単位名
	JA007 string // JAN単位コード
	JA008 string // JANあたり数量
}

func GetJcshmsByJan(conn *sql.DB, jan string) (*JCShms, error) {
	const q = `
SELECT
  jc.JC000, jc.JC009, jc.JC018, jc.JC022, jc.JC030, jc.JC037,
  jc.JC039, jc.JC044,
  jc.JC061, jc.JC062, jc.JC063, jc.JC064, jc.JC065, jc.JC066,
  jn.JA006, jn.JA007, jn.JA008
FROM jcshms jc
LEFT JOIN jancode jn ON jc.JC000 = jn.JA001
WHERE jc.JC000 = ?`

	var r JCShms
	err := conn.QueryRow(q, jan).Scan(
		&r.JC000,
		&r.JC009,
		&r.JC018,
		&r.JC022,
		&r.JC030,
		&r.JC037,
		&r.JC039,
		&r.JC044,
		&r.JC061,
		&r.JC062,
		&r.JC063,
		&r.JC064,
		&r.JC065,
		&r.JC066,
		&r.JA006,
		&r.JA007,
		&r.JA008,
	)
	if errors.Is(err, sql.ErrNoRows) {
		log.Printf("[GetJcshmsByJan] no record for JAN=%q", jan)
		return nil, sql.ErrNoRows
	}
	if err != nil {
		log.Printf("[GetJcshmsByJan] query error for JAN=%q: %v", jan, err)
		return nil, err
	}
	return &r, nil
}


----- C:\Dev\KARASHI\db\sequence.go -----
package db

import (
	"database/sql"
	"fmt"
)

// NextSequence は code_sequences テーブルをトランザクション内でロックして
// last_no をインクリメントし、"MA2Y00000001" のような文字列を返します。
func NextSequence(conn *sql.DB, name string) (string, error) {
	tx, err := conn.Begin()
	if err != nil {
		return "", err
	}
	defer tx.Rollback()

	var last int
	err = tx.QueryRow(
		"SELECT last_no FROM code_sequences WHERE name = ?",
		name,
	).Scan(&last)
	if err != nil {
		return "", err
	}

	last++
	_, err = tx.Exec(
		"UPDATE code_sequences SET last_no = ? WHERE name = ?",
		last, name,
	)
	if err != nil {
		return "", err
	}

	if err := tx.Commit(); err != nil {
		return "", err
	}

	// フォーマットは "MA2Y"+8桁ゼロ埋め
	return fmt.Sprintf("%s%08d", name, last), nil
}

// ExistsMA2ByJan は ma_master テーブルに MA000=key のレコードがあるかを返します。
func ExistsMA2ByJan(conn *sql.DB, key string) (bool, error) {
	const q = `
SELECT 1
  FROM ma_master
 WHERE MA000 = ?
 LIMIT 1`
	var dummy int
	err := conn.QueryRow(q, key).Scan(&dummy)
	if err == sql.ErrNoRows {
		return false, nil
	}
	if err != nil {
		return false, err
	}
	return true, nil
}


----- C:\Dev\KARASHI\loader\loader.go -----
// File: loader/loader.go
package loader

import (
	"database/sql"
	"encoding/csv"
	"fmt"
	"io"
	"os"
	"strings"

	"golang.org/x/text/encoding/japanese"
	"golang.org/x/text/transform"
)

func InitDatabase(db *sql.DB) error {
	if err := applySchema(db); err != nil {
		return fmt.Errorf("schema.sql 読み込み失敗: %w", err)
	}
	if err := loadCSV(db, "SOU/JCSHMS.CSV", "jcshms", 125, false); err != nil {
		return fmt.Errorf("JCSHMS 読み込み失敗: %w", err)
	}
	if err := loadCSV(db, "SOU/JANCODE.CSV", "jancode", 30, true); err != nil {
		return fmt.Errorf("JANCODE 読み込み失敗: %w", err)
	}
	return nil
}

func applySchema(db *sql.DB) error {
	schema, err := os.ReadFile("schema.sql")
	if err != nil {
		return err
	}
	_, err = db.Exec(string(schema))
	return err
}

func loadCSV(db *sql.DB, filepath, tablename string, columns int, skipHeader bool) error {
	f, err := os.Open(filepath)
	if err != nil {
		return err
	}
	defer f.Close()

	r := csv.NewReader(transform.NewReader(f, japanese.ShiftJIS.NewDecoder()))
	r.LazyQuotes = true
	r.FieldsPerRecord = -1
	if skipHeader {
		_, _ = r.Read()
	}

	tx, err := db.Begin()
	if err != nil {
		return err
	}
	defer tx.Rollback()

	ph := make([]string, columns)
	for i := range ph {
		ph[i] = "?"
	}
	stmt, err := tx.Prepare(fmt.Sprintf(
		"INSERT OR REPLACE INTO %s VALUES (%s)",
		tablename, strings.Join(ph, ","),
	))
	if err != nil {
		return err
	}
	defer stmt.Close()

	for {
		row, err := r.Read()
		if err == io.EOF {
			break
		}
		if err != nil || len(row) != columns {
			continue
		}
		args := make([]interface{}, columns)
		for i := range args {
			args[i] = row[i]
		}
		if _, err := stmt.Exec(args...); err != nil {
			continue
		}
	}
	return tx.Commit()
}


----- C:\Dev\KARASHI\model\types.go -----
// File: model/types.go
package model

// UploadedDAT は /uploadDat ハンドラが受け取る生行データを表します。
type UploadedDAT struct {
	Line string // CSV/Dat 一行分の生テキスト
}

// ParsedDAT は .dat ファイルを固定長分解して得られるレコードです。
// Usage ワークフローにも流用できるよう、YJQty/YJUnit を追加しています。
type ParsedDAT struct {
	SlipDate      string  // 処理日付 (YYYYMMDD)
	PartnerCode   string  // 伝票上の得意先コード
	ReceiptNumber string  // 伝票番号
	LineNumber    string  // 行番号
	Flag          int     // 種別フラグ
	JANCode       string  // JANコード
	ProductName   string  // 製品名
	DatQty        float64 // DAT由来の数量
	YJQty         float64 // YJ数量 (Usage/Branch用)
	YJUnit        string  // YJ単位 (Usage/Branch用)
	UnitPrice     float64 // 単価
	Subtotal      float64 // 小計
	ExpiryDate    string  // 有効期限 (YYYYMMDD)
	LotNumber     string  // ロット番号
}

// ParsedUsage は Usage CSV を Shift_JIS→UTF-8 で読み込んだあと得られるレコードです。
// CSV列順: Date, Jc, Yj, Pname, YjQty, YjUnitName
type ParsedUsage struct {
	Date       string  // CSV[0]: Date (YYYYMMDD)
	Jc         string  // CSV[1]: 元JANコード
	Yj         string  // CSV[2]: YJコード
	Pname      string  // CSV[3]: 品名
	YjQty      float64 // CSV[4]: YJ数量
	YjUnitName string  // CSV[5]: YJ単位名称
}

// ARInput は a_records 登録前の共通入力型です。
// Branch→MA→DA すべてで受け渡します。
type ARInput struct {
	Adate  string // adate       日付1
	Apcode string // apcode      得意先コード2
	Arpnum string // arpnum      伝票番号3
	Alnum  string // alnum       行番号4
	Aflag  int    // aflag       種別フラグ5

	Ajc string // ajc         JANコード6
	Ayj string // ayj         YJコード7

	Apname             string  // 品名8
	Akana              string  // 品名かな9
	Apkg               string  // 包装10
	Amaker             string  // メーカー11
	Adatqty            float64 // DAT数量12
	Ajanqty            float64 // JAN数量13
	Ajpu               string  // JAN単位コード14
	Ajanunitname       string  // JAN単位名称15
	Ajanunitcode       string  // JAN単位コード16
	Ayjqty             float64 // YJ数量17
	Ayjpu              string  // YJ単位コード18
	Ayjunitname        string  // YJ単位名称19
	Aunitprice         float64 // 単価20
	Asubtotal          float64 // 小計21
	Ataxamount         float64 // 税額22
	Ataxrate           string  // 税率23
	Aexpdate           string  // 有効期限24
	Alot               string  // ロット番号25
	Adokuyaku          int     // 毒薬フラグ26
	Agekiyaku          int     // 劇薬フラグ27
	Amayaku            int     // 麻薬フラグ28
	Akouseisinyaku     int     // 向精神薬フラグ29
	Akakuseizai        int     // 覚せい剤フラグ30
	Akakuseizaigenryou int     // 覚醒剤原料フラグ31

	Ama string // 1～6 のルート番号32
}

// ARResult は DAハンドラが返す結果エイリアスです。
type ARResult = ARInput

// UsageAflag は brusage フェーズで設定する aflag 値です。
const UsageAflag = 3


----- C:\Dev\KARASHI\static\css\styles.css -----
/* File: static/css/styles.css */

/* リセット & 共通 */
body {
  margin: 0;
  font-family: sans-serif;
}

header nav {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  padding: 8px 20px;
  background: #fff;
  border-bottom: 1px solid #ccc;
  align-items: center;
}
header nav .btn {
  flex: 0 1 auto;
  padding: 6px 12px;
  font-size: 14px;
  cursor: pointer;
}
#printBtn {
  margin-left: auto;
}

#debug {
  background: #f0f0f0;
  padding: 0.5em;
  margin: 1em 20px;
  white-space: pre-wrap;
}

#outputTable {
  width: 100%;
  table-layout: fixed;
  border-collapse: collapse;
  margin: 0 auto 2em;
}
#outputTable th,
#outputTable td {
  border: 1px solid #ccc;
  padding: 4px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
#outputTable thead th {
  position: sticky;
  top: 0;
  background: #f0f0f0;
  z-index: 1;
  text-align: center;
}

/* 列幅（％） */
#outputTable colgroup col:nth-child( 1)  { width:  4.5%; }
#outputTable colgroup col:nth-child( 2)  { width:  2.7%; }
#outputTable colgroup col:nth-child( 3)  { width:  6.4%; }
#outputTable colgroup col:nth-child( 4)  { width:  6.4%; }
#outputTable colgroup col:nth-child( 5)  { width:  6.4%; }
#outputTable colgroup col:nth-child( 6)  { width:  6.4%; }
#outputTable colgroup col:nth-child( 7)  { width:  6.4%; }
#outputTable colgroup col:nth-child( 8)  { width:  2.7%; }
#outputTable colgroup col:nth-child( 9)  { width:  4.0%; }
#outputTable colgroup col:nth-child(10)  { width:  4.0%; }
#outputTable colgroup col:nth-child(11)  { width:  3.2%; }
#outputTable colgroup col:nth-child(12)  { width:  3.2%; }
#outputTable colgroup col:nth-child(13)  { width:  4.0%; }
#outputTable colgroup col:nth-child(14)  { width:  4.0%; }
#outputTable colgroup col:nth-child(15)  { width:  4.0%; }
#outputTable colgroup col:nth-child(16)  { width:  2.7%; }
#outputTable colgroup col:nth-child(17)  { width:  4.5%; }
#outputTable colgroup col:nth-child(18)  { width:  6.4%; }
#outputTable colgroup col:nth-child(19)  { width:  6.4%; }
#outputTable colgroup col:nth-child(20)  { width:  6.4%; }
#outputTable colgroup col:nth-child(21)  { width:  2.7%; }
#outputTable colgroup col:nth-child(22)  { width:  2.6%; }

/* テキスト揃え */
#outputTable td:nth-child( 8),
#outputTable td:nth-child( 9),
#outputTable td:nth-child(11),
#outputTable td:nth-child(13),
#outputTable td:nth-child(14),
#outputTable td:nth-child(15),
#outputTable td:nth-child(16) { text-align: right; }

#outputTable td:nth-child( 1),
#outputTable td:nth-child( 2),
#outputTable td:nth-child( 3),
#outputTable td:nth-child( 4),
#outputTable td:nth-child(17),
#outputTable td:nth-child(21),
#outputTable td:nth-child(22) { text-align: center; }

#outputTable td:nth-child( 5),
#outputTable td:nth-child( 6),
#outputTable td:nth-child( 7),
#outputTable td:nth-child(10),
#outputTable td:nth-child(12),
#outputTable td:nth-child(18),
#outputTable td:nth-child(19),
#outputTable td:nth-child(20) { text-align: left; }

/* フィルタ：MAフラグ "1" or "2" の行のみ表示 */
#outputTable tbody tr { display: none; }
#outputTable tbody tr.modified { display: table-row; }

/* 印刷設定 */
@page {
  size: A4 landscape;
  margin: 10mm 10mm;
}
@media print {
  body * { visibility: hidden; }
  #outputTable,
  #outputTable * { visibility: visible; }
  #outputTable {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
  }
  #outputTable th,
  #outputTable td { font-size: 8px; }
}

----- C:\Dev\KARASHI\static\js\dat.js -----
// File: static/js/dat.js

document.addEventListener("DOMContentLoaded", () => {
  const btn     = document.getElementById("datBtn");
  const input   = document.getElementById("datInput");
  const debug   = document.getElementById("debug");
  const table   = document.getElementById("outputTable");
  const thead   = table.querySelector("thead");
  const tbody   = table.querySelector("tbody");

  // 「納品・返品」クリックでクリア＆ファイル選択
  btn.addEventListener("click", () => {
    thead.innerHTML = "";
    tbody.innerHTML = "";
    debug.textContent = "";
    input.value = null;
    input.click();
  });

  input.addEventListener("change", async () => {
    if (!input.files.length) return;
    debug.textContent = "DATファイルアップロード中…";

    // form にファイル詰めて POST
    const form = new FormData();
    for (const file of input.files) {
      form.append("file", file);
    }

    try {
      const res = await fetch("/uploadDat", { method: "POST", body: form });
      if (!res.ok) {
        debug.textContent = `アップロード失敗: ${res.status}`;
        return;
      }

      const data    = await res.json();
      const records = Array.isArray(data.records) ? data.records : [];

      // カウンタ表示
      debug.textContent =
        `Parsed: ${data.parsed}, Duplicates: ${data.duplicates}, ` +
        `MA: ${data.maCount}, DA: ${data.daCount}`;

      // ヘッダー生成
      thead.innerHTML = `
        <tr>
          <th>日付</th><th>種別</th><th>YJ</th><th>JAN</th><th>製品名</th>
          <th>包装</th><th>メーカー</th><th class="num">個数</th>
          <th class="num">JAN数量</th><th>JAN単位</th>
          <th class="num">YJ数量</th><th>YJ単位</th><th class="num">単価</th>
          <th class="num">金額</th><th class="num">税額</th><th class="num">税率</th>
          <th>期限</th><th>ロット</th><th>得意先</th>
          <th>伝票番号</th><th class="num">行</th><th>MA</th>
        </tr>`;
      tbody.innerHTML = "";

      // デバッグ: Ama の中身と型を一度ログに出す
      console.log(
        "Ama values:",
        records.map(r => ({ Ama: r.Ama, type: typeof r.Ama }))
      );

      // フィルタ：文字列化＋trim して「1〜6」を含むものだけ表示
      records
        .filter(r => {
          const a = String(r.Ama).trim();
          return ["1","2","3","4","5","6"].includes(a);
        })
        .forEach(rec => {
          const tr = document.createElement("tr");
          tr.classList.add("modified");
          tr.innerHTML = `
            <td>${rec.Adate            || ""}</td>
            <td>${rec.Aflag            || ""}</td>
            <td>${rec.Ayj              || ""}</td>
            <td>${rec.Ajc              || ""}</td>
            <td>${rec.Apname           || ""}</td>
            <td>${rec.Apkg             || ""}</td>
            <td>${rec.Amaker           || ""}</td>
            <td class="num">${rec.Adatqty    || ""}</td>
            <td class="num">${rec.Ajanqty    || ""}</td>
            <td>${rec.Ajanunitname     || ""}</td>
            <td class="num">${rec.Ayjqty     || ""}</td>
            <td>${rec.Ayjunitname      || ""}</td>
            <td class="num">${rec.Aunitprice || ""}</td>
            <td class="num">${rec.Asubtotal  || ""}</td>
            <td class="num">${rec.Ataxamount || ""}</td>
            <td class="num">${rec.Ataxrate   || ""}</td>
            <td>${rec.Aexpdate         || ""}</td>
            <td>${rec.Alot             || ""}</td>
            <td>${rec.Apcode           || ""}</td>
            <td>${rec.Arpnum           || ""}</td>
            <td class="num">${rec.Alnum      || ""}</td>
            <td>${String(rec.Ama).trim()  || ""}</td>
          `;
          tbody.appendChild(tr);
        });

    } catch (err) {
      console.error(err);
      debug.textContent = "DATアップロードエラー: " + err.message;
    }
  });
});

----- C:\Dev\KARASHI\static\js\usage.js -----
// File: static/js/usage.js

document.addEventListener("DOMContentLoaded", () => {
  const btn     = document.getElementById("usageBtn");
  const input   = document.getElementById("usageInput");
  const debug   = document.getElementById("debug");
  const table   = document.getElementById("outputTable");
  const thead   = table.querySelector("thead");
  const tbody   = table.querySelector("tbody");

  // USAGE ボタン押下でテーブル初期化＆ファイル選択ダイアログ
  btn.addEventListener("click", () => {
    debug.textContent = "";
    thead.innerHTML = `
      <tr>
        <th>日付</th><th>種別</th><th>YJ</th><th>JAN</th><th>製品名</th>
        <th>包装</th><th>メーカー</th><th class="num">個数</th>
        <th class="num">JAN数量</th><th>JAN単位</th>
        <th class="num">YJ数量</th><th>YJ単位</th><th class="num">単価</th>
        <th class="num">金額</th><th class="num">税額</th><th class="num">税率</th>
        <th>期限</th><th>ロット</th><th>得意先</th>
        <th>伝票番号</th><th class="num">行</th><th>MA</th>
      </tr>`;
    tbody.innerHTML = "";
    input.value = null;
    input.click();
  });

  // ファイル選択 → サーバへアップロード → JSONで受信 → テーブル描画
  input.addEventListener("change", async () => {
    if (!input.files.length) return;
    debug.textContent = "USAGEファイルアップロード中…";

    const form = new FormData();
    for (const file of input.files) {
      form.append("file", file);
    }

    try {
      const res = await fetch("/uploadUsage", {
        method: "POST",
        body: form
      });
      if (!res.ok) {
        debug.textContent = `アップロード失敗: ${res.status}`;
        return;
      }

      const records = await res.json();
      debug.textContent = `受信件数: ${records.length}`;

      tbody.innerHTML = "";
      records
        .filter(r => ["1","2","3","4","5","6"].includes(String(r.Ama).trim()))
        .forEach(rec => {
          const tr = document.createElement("tr");
          tr.classList.add("modified");
          tr.innerHTML = `
            <td>${rec.Adate || ""}</td>
            <td>${rec.Aflag || ""}</td>
            <td>${rec.Ayj   || ""}</td>
            <td>${rec.Ajc   || ""}</td>
            <td>${rec.Apname|| ""}</td>
            <td>${rec.Apkg  || ""}</td>
            <td>${rec.Amaker|| ""}</td>
            <td class="num">${rec.Adatqty    || ""}</td>
            <td class="num">${rec.Ajanqty    || ""}</td>
            <td>${rec.Ajanunitname || ""}</td>
            <td class="num">${rec.Ayjqty     || ""}</td>
            <td>${rec.Ayjunitname  || ""}</td>
            <td class="num">${rec.Aunitprice || ""}</td>
            <td class="num">${rec.Asubtotal  || ""}</td>
            <td class="num">${rec.Ataxamount || ""}</td>
            <td class="num">${rec.Ataxrate   || ""}</td>
            <td>${rec.Aexpdate      || ""}</td>
            <td>${rec.Alot          || ""}</td>
            <td>${rec.Apcode        || ""}</td>
            <td>${rec.Arpnum        || ""}</td>
            <td class="num">${rec.Alnum    || ""}</td>
            <td>${String(rec.Ama).trim()     || ""}</td>
          `;
          tbody.appendChild(tr);
        });
    } catch (err) {
      console.error(err);
      debug.textContent = "アップロードエラー: " + err.message;
    }
  });
});

----- C:\Dev\KARASHI\static\index.html -----
<!-- File: static/index.html -->
<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>YAMATO 集計システム</title>
  <link rel="stylesheet" href="/static/css/styles.css" />
  <link rel="icon" href="/favicon.ico" type="image/x-icon" />
  <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
</head>
<body>
  <header id="header">
    <nav>
      <button id="datBtn" class="btn">納品・返品</button>
      <button id="usageBtn" class="btn">USAGE</button>
      <button id="aggregateBtn" class="btn">集計</button>
      <button id="inventoryBtn" class="btn">棚卸</button>
      <button id="ma2Btn" class="btn">MA2編集</button>
      <button id="inoutBtn" class="btn">出庫・入庫</button>
      <button id="printBtn" class="btn">印刷</button>
    </nav>
  </header>

  <!-- ファイル選択ボタン（非表示） -->
  <input type="file" id="datInput" multiple style="display:none" />
  <input type="file" id="usageInput" multiple style="display:none" />

  <!-- デバッグメッセージ欄 -->
  <pre id="debug"></pre>

  <!-- データテーブル -->
  <table id="outputTable">
    <colgroup>
      <col><col><col><col><col><col><col>
      <col><col><col><col><col><col><col>
      <col><col><col><col><col><col><col>
      <col><col>
    </colgroup>
    <thead>
      <tr>
        <th>日付</th>
        <th>種別</th>
        <th>YJ</th>
        <th>JAN</th>
        <th>製品名</th>
        <th>包装</th>
        <th>メーカー</th>
        <th>個数</th>
        <th>JAN数量</th>
        <th>JAN単位</th>
        <th>YJ数量</th>
        <th>YJ単位</th>
        <th>単価</th>
        <th>金額</th>
        <th>税額</th>
        <th>税率</th>
        <th>期限</th>
        <th>ロット</th>
        <th>得意先</th>
        <th>伝票番号</th>
        <th>行</th>
        <th>MA</th>
      </tr>
    </thead>
    <tbody>
      <!-- JS で挿入 -->
    </tbody>
  </table>

  <!-- スクリプト読み込み -->
  <script src="/static/js/dat.js"></script>
  <script src="/static/js/usage.js"></script>
  <script>
    // 印刷ボタン動作
    document.getElementById("printBtn")
      .addEventListener("click", () => window.print());
  </script>
</body>
</html>

----- C:\Dev\KARASHI\tani\tani.go -----
// File: tani/tani.go
package tani

import (
	"encoding/csv"
	"fmt"
	"io"
	"os"

	"golang.org/x/text/encoding/japanese"
	"golang.org/x/text/transform"
)

// internalMap にコード→名称を保持します
var internalMap map[string]string

// LoadTANIFile は ShiftJIS で保存された単位マスターCSVを読み込み、
// code→名称のマップを返します。
func LoadTANIFile(path string) (map[string]string, error) {
	file, err := os.Open(path)
	if err != nil {
		return nil, fmt.Errorf("LoadTANIFile: open %s: %w", path, err)
	}
	defer file.Close()

	// ShiftJIS を UTF-8 に変換しつつ読み込む
	decoder := japanese.ShiftJIS.NewDecoder()
	reader := csv.NewReader(transform.NewReader(file, decoder))
	reader.LazyQuotes = true
	reader.FieldsPerRecord = -1

	m := make(map[string]string)
	for {
		record, err := reader.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			return nil, fmt.Errorf("LoadTANIFile: read %s: %w", path, err)
		}
		if len(record) < 2 {
			continue
		}
		code := record[0]
		name := record[1]
		m[code] = name
	}
	internalMap = m
	return m, nil
}

// ResolveName は与えられたコードの名称を返します。
// マップに存在しない場合はコード自身を返します。
func ResolveName(code string) string {
	if internalMap == nil {
		return code
	}
	if name, ok := internalMap[code]; ok {
		return name
	}
	return code
}


----- C:\Dev\KARASHI\usage\brusage.go -----
package usage

import (
	"log"

	"karashi/model"
)

// BranchUsage は現段階では ParsedUsage の JC 有無だけをログに出力します。
// 「JC が空白 → group=12」「JC あり → group=3456」を示します。
func branchUsage(parsed []model.ParsedUsage) {
	for _, rec := range parsed {
		group := "12"
		if rec.Jc != "" {
			group = "3456"
		}
		log.Printf("JC: %q    branch group: %s", rec.Jc, group)
	}
}


----- C:\Dev\KARASHI\usage\pausage.go -----
package usage

import (
	"encoding/csv"
	"io"
	"log"
	"strconv"

	"karashi/model"

	"golang.org/x/text/encoding/japanese"
	"golang.org/x/text/transform"
)

// ParseUsage は Shift_JIS の Usage CSV を読み込み、
// model.ParsedUsage のスライスを返します。
// フォーマット: Date,Jc,Yj,Pname,Yjqty,Yjunitname （ヘッダーなし）
func ParseUsage(r io.Reader) ([]model.ParsedUsage, error) {
	// Shift_JIS → UTF-8 変換
	decoder := japanese.ShiftJIS.NewDecoder()
	reader := csv.NewReader(transform.NewReader(r, decoder))
	reader.LazyQuotes = true
	reader.FieldsPerRecord = -1

	var out []model.ParsedUsage
	for {
		rec, err := reader.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			log.Printf("ParseUsage: read error: %v", err)
			continue
		}
		// 必要フィールド数を満たすかチェック
		if len(rec) < 6 {
			log.Printf("ParseUsage: unexpected field count: got %d, want ≥6", len(rec))
			continue
		}

		// YJ数量を float64 に変換
		qty, err := strconv.ParseFloat(rec[4], 64)
		if err != nil {
			log.Printf("ParseUsage: parse YjQty error for %q: %v", rec[4], err)
			qty = 0
		}

		u := model.ParsedUsage{
			Date:       rec[0],
			Jc:         rec[2],
			Yj:         rec[1],
			Pname:      rec[3],
			YjQty:      qty,
			YjUnitName: rec[5],
		}
		out = append(out, u)
	}

	return out, nil
}


----- C:\Dev\KARASHI\usage\types.go -----
// File: usage/types.go
package usage

import "karashi/model"

// ―――――――――――――――――――
// Usage CSV の列インデックス定義
//
// フォーマット（ヘッダーなし）:
//   {Date,Yj,Jc,Pname,YjQty,YjUnitName}
const (
	UsageDateIndex       = iota // CSV[0]
	UsageYjIndex                // CSV[1]
	UsageJcIndex                // CSV[2]
	UsagePnameIndex             // CSV[3]
	UsageYjQtyIndex             // CSV[4]
	UsageYjUnitNameIndex        // CSV[5]
)

// ParsedUsage は Shift_JIS→UTF-8 変換後の 1 行分レコードです。
// フィールド順: {Date,Jc,Yj,Pname,YjQty,YjUnitName}
type ParsedUsage struct {
	Date       string  // CSV[UsageDateIndex]
	Jc         string  // CSV[UsageJcIndex]
	Yj         string  // CSV[UsageYjIndex]
	Pname      string  // CSV[UsagePnameIndex]
	YjQty      float64 // CSV[UsageYjQtyIndex]
	YjUnitName string  // CSV[UsageYjUnitNameIndex]
}

// ――― brusage フェーズ用定数 ―――
const BranchAflag = model.UsageAflag // = 3

// Ama（グループ番号）定義
const (
	Ama1 = "1"
	Ama2 = "2"
	Ama3 = "3"
	Ama4 = "4"
	Ama5 = "5"
	Ama6 = "6"
)

// BrUsage は BranchUsage の出力型です。
// フィールド順: {Date,3,Jc,Yj,Pname,YjQty,YjUnitName,Ama}
type BrUsage struct {
	Date       string  // CSV[UsageDateIndex]
	Aflag      int     // = BranchAflag (3)
	Jc         string  // CSV[UsageJcIndex]
	Yj         string  // CSV[UsageYjIndex]
	Pname      string  // CSV[UsagePnameIndex]
	YjQty      float64 // CSV[UsageYjQtyIndex]
	YjUnitName string  // CSV[UsageYjUnitNameIndex]
	Ama        string  // "1"～"6"
}

// ARInput は a_records 登録前の共通入力型です。
// フィールド順: [
//   Adate,Apcode,Arpnum,Alnum,Aflag,Ajc,Ayj,Apname,Akana,Apkg,Amaker,
//   Adatqty,Ajanqty,Ajpu,Ajanunitnm,Ajanunitcd,Ayjqty,Ayjpu,Ayjunitnm,
//   Aunitprice,Asubtotal,Ataxamt,Ataxrate,Aexpdate,Alot,
//   Adokuyaku,Agekiyaku,Amayaku,Akouseisinyaku,Akakuseizai,Akakuseizaigenryou,Ama
// ]
type ARInput struct {
	Adate              string  // adate               日付1
	Apcode             string  // apcode              得意先コード2
	Arpnum             string  // arpnum              伝票番号3
	Alnum              string  // alnum               行番号4
	Aflag              int     // aflag               種別フラグ5
	Ajc                string  // ajc                 JANコード6
	Ayj                string  // ayj                 YJコード7
	Apname             string  // apname              品名8
	Akana              string  // akana               品名かな9
	Apkg               string  // apkg                包装10
	Amaker             string  // amaker              メーカー11
	Adatqty            float64 // adatqty             DAT数量12
	Ajanqty            float64 // ajanqty             JAN数量13
	Ajpu               string  // ajpu                JAN単位コード14
	Ajanunitnm         string  // ajanunitname        JAN単位名称15
	Ajanunitcd         string  // ajanunitcode        JAN単位コード16
	Ayjqty             float64 // ayjqty              YJ数量17
	Ayjpu              string  // ayjpu               YJ単位コード18
	Ayjunitnm          string  // ayjunitname         YJ単位名称19
	Aunitprice         float64 // aunitprice          単価20
	Asubtotal          float64 // asubtotal           小計21
	Ataxamt            float64 // ataxamount          税額22
	Ataxrate           string  // ataxrate            税率23
	Aexpdate           string  // aexpdate            有効期限24
	Alot               string  // alot                ロット番号25
	Adokuyaku          int     // adokuyaku           毒薬フラグ26
	Agekiyaku          int     // agekiyaku           劇薬フラグ27
	Amayaku            int     // amayaku             麻薬フラグ28
	Akouseisinyaku     int     // akouseisinyaku      向精神薬フラグ29
	Akakuseizai        int     // akakuseizai         覚せい剤フラグ30
	Akakuseizaigenryou int     // akakuseizaigenryou  覚醒剤原料フラグ31
	Ama                string  // ama                 ルート番号32
}

// MaMaster は ma_master テーブルの 1 レコードを表現します。
// フィールド順: [MA000,MA009,MA018,MA022,MA030,MA037,MA039,MA044,
//               MA061,MA062,MA063,MA064,MA065,MA066,MA131,MA132,MA133]
type MaMaster struct {
	MA000 string `db:"MA000" json:"MA000"`
	MA009 string `db:"MA009" json:"MA009"`
	MA018 string `db:"MA018" json:"MA018"`
	MA022 string `db:"MA022" json:"MA022"`
	MA030 string `db:"MA030" json:"MA030"`
	MA037 string `db:"MA037" json:"MA037"`
	MA039 string `db:"MA039" json:"MA039"`
	MA044 string `db:"MA044" json:"MA044"`
	MA061 string `db:"MA061" json:"MA061"`
	MA062 string `db:"MA062" json:"MA062"`
	MA063 string `db:"MA063" json:"MA063"`
	MA064 string `db:"MA064" json:"MA064"`
	MA065 string `db:"MA065" json:"MA065"`
	MA066 string `db:"MA066" json:"MA066"`
	MA131 string `db:"MA131" json:"MA131"`
	MA132 string `db:"MA132" json:"MA132"`
	MA133 string `db:"MA133" json:"MA133"`
}


----- C:\Dev\KARASHI\usage\upusage.go -----
package usage

import (
	"database/sql"
	"encoding/json"
	"log"
	"net/http"

	"karashi/model"
)

// UploadUsageHandler は HTML から送信された Shift_JIS の Usage CSV を受け取り、
// パース後には branchUsage でログ出力し、最終的に JSON を返します。
func UploadUsageHandler(db *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		if r.Method != http.MethodPost {
			http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
			return
		}

		if err := r.ParseMultipartForm(32 << 20); err != nil {
			http.Error(w, "failed to parse multipart form: "+err.Error(), http.StatusBadRequest)
			return
		}
		defer r.MultipartForm.RemoveAll()

		var all []model.ParsedUsage
		files := r.MultipartForm.File["file"]
		for _, fh := range files {
			f, err := fh.Open()
			if err != nil {
				log.Printf("UploadUsageHandler: open file error: %v", err)
				continue
			}

			records, err := ParseUsage(f)
			f.Close()
			if err != nil {
				log.Printf("UploadUsageHandler: parse error: %v", err)
				continue
			}
			all = append(all, records...)
		}

		// 分岐ログを出力
		branchUsage(all)

		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		if err := json.NewEncoder(w).Encode(all); err != nil {
			log.Printf("UploadUsageHandler: json encode error: %v", err)
		}
	}
}


----- C:\Dev\KARASHI\main.go -----
// File: main.go
package main

import (
	"context"
	"database/sql"
	"flag"
	"log"
	"net/http"
	"os"
	"os/exec"
	"os/signal"
	"runtime"
	"syscall"
	"time"

	_ "github.com/mattn/go-sqlite3"

	"karashi/loader"
	"karashi/tani"
	"karashi/usage"
)

func main() {
	port := flag.String("port", "8080", "HTTP port")
	dbPath := flag.String("db", "yamato.db", "SQLite file path")
	flag.Parse()

	db, err := sql.Open("sqlite3", *dbPath)
	if err != nil {
		log.Fatalf("DB open failed: %v", err)
	}
	defer db.Close()

	// スキーマ＆マスター初期ロード
	if err := loader.InitDatabase(db); err != nil {
		log.Fatalf("master init failed: %v", err)
	}

	// 単位マスター読み込み
	if _, err := tani.LoadTANIFile("SOU/TANI.CSV"); err != nil {
		log.Fatalf("tani load failed: %v", err)
	}

	// HTTP ハンドラ登録
	mux := http.NewServeMux()
	//mux.HandleFunc("/uploadDat", dat.UploadDat10(db))
	mux.Handle("/uploadUsage", usage.UploadUsageHandler(db))
	mux.Handle("/static/", http.StripPrefix("/static/",
		http.FileServer(http.Dir("./static"))))
	mux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		http.ServeFile(w, r, "./static/index.html")
	})

	srv := &http.Server{
		Addr:         ":" + *port,
		Handler:      loggingMiddleware(mux),
		ReadTimeout:  10 * time.Second,
		WriteTimeout: 10 * time.Second,
		IdleTimeout:  60 * time.Second,
	}

	go func() {
		log.Printf("→ starting on :%s", *port)
		openBrowser("http://localhost:" + *port)
		if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			log.Fatalf("listen error: %v", err)
		}
	}()

	// Graceful shutdown
	stop := make(chan os.Signal, 1)
	signal.Notify(stop, os.Interrupt, syscall.SIGTERM)
	<-stop
	log.Println("⏳ shutting down…")

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	if err := srv.Shutdown(ctx); err != nil {
		log.Fatalf("shutdown failed: %v", err)
	}
	log.Println("✅ server stopped")
}

func openBrowser(url string) {
	var cmd *exec.Cmd
	switch runtime.GOOS {
	case "windows":
		cmd = exec.Command("rundll32", "url.dll,FileProtocolHandler", url)
	case "darwin":
		cmd = exec.Command("open", url)
	default:
		cmd = exec.Command("xdg-open", url)
	}
	_ = cmd.Start()
}

func loggingMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		start := time.Now()
		next.ServeHTTP(w, r)
		log.Printf("%s %s %s", r.Method, r.URL.Path, time.Since(start))
	})
}


----- C:\Dev\KARASHI\schema.sql -----
CREATE TABLE IF NOT EXISTS code_sequences (
  name    TEXT PRIMARY KEY,
  last_no INTEGER NOT NULL
);
INSERT OR IGNORE INTO code_sequences(name,last_no) VALUES ('MA2Y',0);




 CREATE TABLE IF NOT EXISTS ma_master (
  MA000    TEXT    PRIMARY KEY,
  MA009    TEXT    UNIQUE NOT NULL DEFAULT '',   -- 発番済 YJ コード
  MA018    TEXT    NOT NULL DEFAULT '',          -- 品名
  MA022    TEXT    NOT NULL DEFAULT '',          -- 品名かな
  MA030    TEXT    NOT NULL DEFAULT '',          -- メーカー
  MA037    TEXT    NOT NULL DEFAULT '',          -- 包装
  MA039    TEXT    NOT NULL DEFAULT '',          -- YJ側単位コード
  MA044    TEXT    NOT NULL DEFAULT '',          -- YJ側数量文字列
  MA061    INTEGER NOT NULL DEFAULT 0,           -- 毒薬
  MA062    INTEGER NOT NULL DEFAULT 0,           -- 劇薬
  MA063    INTEGER NOT NULL DEFAULT 0,           -- 麻薬
  MA064    INTEGER NOT NULL DEFAULT 0,           -- 向精神薬
  MA065    INTEGER NOT NULL DEFAULT 0,           -- 覚せい剤
  MA066    INTEGER NOT NULL DEFAULT 0,           -- 覚醒剤原料
  MA131    TEXT    NOT NULL DEFAULT '',          -- JAN単位名
  MA132    TEXT    NOT NULL DEFAULT '',          -- JAN単位コード
  MA133    TEXT    NOT NULL DEFAULT ''           -- JANあたり数量
 );





CREATE INDEX IF NOT EXISTS idxMaMasterMA009
  ON ma_master(MA009);



CREATE INDEX IF NOT EXISTS idx_master_MA009
  ON ma_master(MA009);


CREATE TABLE IF NOT EXISTS a_records (
  adate                      TEXT    NOT NULL,
  apcode                     TEXT    NOT NULL,
  arpnum                     TEXT    NOT NULL,
  alnum                      TEXT    NOT NULL,
  aflag                      INTEGER NOT NULL,
  ajc                        TEXT    NOT NULL,
  ayj                        TEXT,
  apname                     TEXT,
  akana                      TEXT,
  apkg                       TEXT,
  amaker                     TEXT,
  adatqty                    REAL,
  ajanqty                    REAL,
  ajpu                       REAL,
  ajanunitname               TEXT,
  ajanunitcode               TEXT,
  ayjqty                     REAL,
  ayjpu                      TEXT,
  ayjunitname                TEXT,
  aunitprice                 REAL,
  asubtotal                  REAL,
  ataxamount                 REAL,
  ataxrate                   TEXT,
  aexpdate                   TEXT,
  alot                       TEXT,
  adokuyaku                  INTEGER DEFAULT 0,
  agekiyaku                  INTEGER DEFAULT 0,
  amayaku                    INTEGER DEFAULT 0,
  akouseisinyaku             INTEGER DEFAULT 0,
  akakuseizai                INTEGER DEFAULT 0,
  akakuseizaigenryou         INTEGER DEFAULT 0,
  ama                        TEXT,
  PRIMARY KEY (apcode, adate, arpnum, alnum, aflag)
);

-- ソート／フィルタ用インデックス
CREATE INDEX IF NOT EXISTS idx_ar_apname_kana
  ON a_records(akana);
CREATE INDEX IF NOT EXISTS idx_ar_adokuyaku
  ON a_records(adokuyaku);
-- 必要に応じて他フラグにも INDEX を貼る

CREATE TABLE IF NOT EXISTS jcshms (
JC000 TEXT,
JC001 TEXT,
JC002 TEXT,
JC003 TEXT,
JC004 TEXT,
JC005 TEXT,
JC006 TEXT,
JC007 TEXT,
JC008 TEXT,
JC009 TEXT,
JC010 TEXT,
JC011 TEXT,
JC012 TEXT,
JC013 TEXT,
JC014 TEXT,
JC015 TEXT,
JC016 TEXT,
JC017 TEXT,
JC018 TEXT,
JC019 TEXT,
JC020 TEXT,
JC021 TEXT,
JC022 TEXT,
JC023 TEXT,
JC024 TEXT,
JC025 TEXT,
JC026 TEXT,
JC027 TEXT,
JC028 TEXT,
JC029 TEXT,
JC030 TEXT,
JC031 TEXT,
JC032 TEXT,
JC033 TEXT,
JC034 TEXT,
JC035 TEXT,
JC036 TEXT,
JC037 TEXT,
JC038 TEXT,
JC039 TEXT,
JC040 TEXT,
JC041 TEXT,
JC042 TEXT,
JC043 TEXT,
JC044 TEXT,
JC045 TEXT,
JC046 TEXT,
JC047 TEXT,
JC048 TEXT,
JC049 TEXT,
JC050 TEXT,
JC051 TEXT,
JC052 TEXT,
JC053 TEXT,
JC054 TEXT,
JC055 TEXT,
JC056 TEXT,
JC057 TEXT,
JC058 TEXT,
JC059 TEXT,
JC060 TEXT,
JC061 TEXT,
JC062 TEXT,
JC063 TEXT,
JC064 TEXT,
JC065 TEXT,
JC066 TEXT,
JC067 TEXT,
JC068 TEXT,
JC069 TEXT,
JC070 TEXT,
JC071 TEXT,
JC072 TEXT,
JC073 TEXT,
JC074 TEXT,
JC075 TEXT,
JC076 TEXT,
JC077 TEXT,
JC078 TEXT,
JC079 TEXT,
JC080 TEXT,
JC081 TEXT,
JC082 TEXT,
JC083 TEXT,
JC084 TEXT,
JC085 TEXT,
JC086 TEXT,
JC087 TEXT,
JC088 TEXT,
JC089 TEXT,
JC090 TEXT,
JC091 TEXT,
JC092 TEXT,
JC093 TEXT,
JC094 TEXT,
JC095 TEXT,
JC096 TEXT,
JC097 TEXT,
JC098 TEXT,
JC099 TEXT,
JC100 TEXT,
JC101 TEXT,
JC102 TEXT,
JC103 TEXT,
JC104 TEXT,
JC105 TEXT,
JC106 TEXT,
JC107 TEXT,
JC108 TEXT,
JC109 TEXT,
JC110 TEXT,
JC111 TEXT,
JC112 TEXT,
JC113 TEXT,
JC114 TEXT,
JC115 TEXT,
JC116 TEXT,
JC117 TEXT,
JC118 TEXT,
JC119 TEXT,
JC120 TEXT,
JC121 TEXT,
JC122 TEXT,
JC123 TEXT,
JC124 TEXT,
PRIMARY KEY(JC000)
);

CREATE TABLE IF NOT EXISTS jancode (
JA000 TEXT,
JA001 TEXT,
JA002 TEXT,
JA003 TEXT,
JA004 TEXT,
JA005 TEXT,
JA006 TEXT,
JA007 TEXT,
JA008 TEXT,
JA009 TEXT,
JA010 TEXT,
JA011 TEXT,
JA012 TEXT,
JA013 TEXT,
JA014 TEXT,
JA015 TEXT,
JA016 TEXT,
JA017 TEXT,
JA018 TEXT,
JA019 TEXT,
JA020 TEXT,
JA021 TEXT,
JA022 TEXT,
JA023 TEXT,
JA024 TEXT,
JA025 TEXT,
JA026 TEXT,
JA027 TEXT,
JA028 TEXT,
JA029 TEXT,
PRIMARY KEY(JA001)
);


-- File: Sql/Schema/CreatePartnerMaster.sql

-- パートナーコード → 社名マスター
CREATE TABLE IF NOT EXISTS partner_master (
  id   INTEGER PRIMARY KEY AUTOINCREMENT,
  code TEXT    NOT NULL UNIQUE,    -- パートナーコード
  name TEXT    NOT NULL            -- 社名
);

-- 初期４社登録
INSERT OR IGNORE INTO partner_master (code, name) VALUES
  ('902020014', 'スズケン'),
  ('901660013', 'メディセオ'),
  ('902690019', '中北薬品'),
  ('902960013', 'アルフレッサ');



