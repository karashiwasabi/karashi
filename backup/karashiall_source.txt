----- C:\Dev\KARASHI\jancode\package.go -----
// File: jancode/package.go package jancode  import ( 	"database/sql" 	"fmt" )  // JARecord は jancode テーブルの 1 行を表します。 // 必要なフィールドのみ宣言してください。 type JARecord struct { 	JA000 string // 管理コード 	JA006 string // JAN数量 	JA007 string // JAN単位コード 	JA008 string // YJ換算数量 	JA009 string // YJ換算単位コード }  // QueryByJan は jancode テーブルから key=jan のレコードを返します。 func QueryByJan(db *sql.DB, jan string) (*JARecord, error) { 	const sqlstr = `         SELECT             JA000,   -- 管理コード             JA006,   -- JAN数量             JA007,   -- JAN単位コード             JA008,   -- YJ換算数量             JA009    -- YJ換算単位コード         FROM jancode         WHERE JA001 = ?  -- 主キー JA001（JANコード）で検索     ` 	var r JARecord 	err := db.QueryRow(sqlstr, jan).Scan( 		&r.JA000, 		&r.JA006, 		&r.JA007, 		&r.JA008, 		&r.JA009, 	) 	if err == sql.ErrNoRows { 		return nil, nil 	} 	if err != nil { 		return nil, fmt.Errorf("jancode lookup failed: %w", err) 	} 	return &r, nil }

----- C:\Dev\KARASHI\jcshms\package.go -----
// File: jcshms/package.go package jcshms  import ( 	"database/sql" 	"fmt" )  // JCRecord は jcshms テーブルの 1 行を表します。 // 必要なフィールドのみ宣言してください。 type JCRecord struct { 	JC000 string // JANコード 	JC009 string // YJコード 	JC018 string // 商品名 	JC022 string // 商品名かなソートキー 	JC037 string // 包装形態 	JC039 string // 包装単位コード 	JC044 string // 包装総量 	JC061 string // 毒薬フラグ 	JC062 string // 劇薬フラグ 	JC063 string // 麻薬フラグ 	JC064 string // 向精神薬フラグ }  // QueryByJan は jcshms テーブルから key=jan のレコードを返します。 func QueryByJan(db *sql.DB, jan string) (*JCRecord, error) { 	const sqlstr = ` SELECT   JC000,   JC009,   JC018,   JC022,   JC037,   JC039,   JC044,   JC061,   JC062,   JC063,   JC064 FROM jcshms WHERE JC000 = ? ` 	var r JCRecord 	err := db.QueryRow(sqlstr, jan).Scan( 		&r.JC000, 		&r.JC009, 		&r.JC018, 		&r.JC022, 		&r.JC037, 		&r.JC039, 		&r.JC044, 		&r.JC061, 		&r.JC062, 		&r.JC063, 		&r.JC064, 	) 	if err == sql.ErrNoRows { 		return nil, nil 	} 	if err != nil { 		return nil, fmt.Errorf("jcshms lookup failed: %w", err) 	} 	return &r, nil }

----- C:\Dev\KARASHI\loader\loader.go -----
// File: loader/loader.go package loader  import ( 	"database/sql" 	"encoding/csv" 	"fmt" 	"io" 	"os" 	"strings"  	"golang.org/x/text/encoding/japanese" 	"golang.org/x/text/transform" )  func InitDatabase(db *sql.DB) error { 	if err := applySchema(db); err != nil { 		return fmt.Errorf("schema.sql 読み込み失敗: %w", err) 	} 	if err := loadCSV(db, "SOU/JCSHMS.CSV", "jcshms", 125, false); err != nil { 		return fmt.Errorf("JCSHMS 読み込み失敗: %w", err) 	} 	if err := loadCSV(db, "SOU/JANCODE.CSV", "jancode", 30, true); err != nil { 		return fmt.Errorf("JANCODE 読み込み失敗: %w", err) 	} 	return nil }  func applySchema(db *sql.DB) error { 	schema, err := os.ReadFile("schema.sql") 	if err != nil { 		return err 	} 	_, err = db.Exec(string(schema)) 	return err }  func loadCSV(db *sql.DB, filepath, tablename string, columns int, skipHeader bool) error { 	f, err := os.Open(filepath) 	if err != nil { 		return err 	} 	defer f.Close()  	r := csv.NewReader(transform.NewReader(f, japanese.ShiftJIS.NewDecoder())) 	r.LazyQuotes = true 	r.FieldsPerRecord = -1 	if skipHeader { 		_, _ = r.Read() 	}  	tx, err := db.Begin() 	if err != nil { 		return err 	} 	defer tx.Rollback()  	ph := make([]string, columns) 	for i := range ph { 		ph[i] = "?" 	} 	stmt, err := tx.Prepare(fmt.Sprintf( 		"INSERT OR REPLACE INTO %s VALUES (%s)", 		tablename, strings.Join(ph, ","), 	)) 	if err != nil { 		return err 	} 	defer stmt.Close()  	for { 		row, err := r.Read() 		if err == io.EOF { 			break 		} 		if err != nil || len(row) != columns { 			continue 		} 		args := make([]interface{}, columns) 		for i := range args { 			args[i] = row[i] 		} 		if _, err := stmt.Exec(args...); err != nil { 			continue 		} 	} 	return tx.Commit() }

----- C:\Dev\KARASHI\ma0\full.go -----
// Code generated by gen_full.go; DO NOT EDIT. //go:generate go run gen_full.go > full.go  package ma0  // MA0Full は ma0 テーブルの全155フィールドを1:1マッピングした構造体です type MA0Full struct {     MA000 string     MA001 string     MA002 string     MA003 string     MA004 string     MA005 string     MA006 string     MA007 string     MA008 string     MA009 string     MA010 string     MA011 string     MA012 string     MA013 string     MA014 string     MA015 string     MA016 string     MA017 string     MA018 string     MA019 string     MA020 string     MA021 string     MA022 string     MA023 string     MA024 string     MA025 string     MA026 string     MA027 string     MA028 string     MA029 string     MA030 string     MA031 string     MA032 string     MA033 string     MA034 string     MA035 string     MA036 string     MA037 string     MA038 string     MA039 string     MA040 string     MA041 string     MA042 string     MA043 string     MA044 string     MA045 string     MA046 string     MA047 string     MA048 string     MA049 string     MA050 string     MA051 string     MA052 string     MA053 string     MA054 string     MA055 string     MA056 string     MA057 string     MA058 string     MA059 string     MA060 string     MA061 string     MA062 string     MA063 string     MA064 string     MA065 string     MA066 string     MA067 string     MA068 string     MA069 string     MA070 string     MA071 string     MA072 string     MA073 string     MA074 string     MA075 string     MA076 string     MA077 string     MA078 string     MA079 string     MA080 string     MA081 string     MA082 string     MA083 string     MA084 string     MA085 string     MA086 string     MA087 string     MA088 string     MA089 string     MA090 string     MA091 string     MA092 string     MA093 string     MA094 string     MA095 string     MA096 string     MA097 string     MA098 string     MA099 string     MA100 string     MA101 string     MA102 string     MA103 string     MA104 string     MA105 string     MA106 string     MA107 string     MA108 string     MA109 string     MA110 string     MA111 string     MA112 string     MA113 string     MA114 string     MA115 string     MA116 string     MA117 string     MA118 string     MA119 string     MA120 string     MA121 string     MA122 string     MA123 string     MA124 string      MA125 string     MA126 string     MA127 string     MA128 string     MA129 string     MA130 string     MA131 string     MA132 string     MA133 string     MA134 string     MA135 string     MA136 string     MA137 string     MA138 string     MA139 string     MA140 string     MA141 string     MA142 string     MA143 string     MA144 string     MA145 string     MA146 string     MA147 string     MA148 string     MA149 string     MA150 string     MA151 string     MA152 string     MA153 string     MA154 string }

----- C:\Dev\KARASHI\ma0\gen_full.go -----
//go:build ignore // +build ignore  package main  import "fmt"  func main() { 	fmt.Println("package ma0") 	fmt.Println() 	fmt.Println("// Code generated by gen_full.go; DO NOT EDIT.") 	fmt.Println("// MA0Full は ma0 テーブルの全155フィールドを1:1マッピングした構造体です") 	fmt.Println("type MA0Full struct {") 	// 0～154 のフィールドを MA000～MA154 として出力 	for i := 0; i <= 154; i++ { 		fmt.Printf("    MA%03d string\n", i) 	} 	fmt.Println("}") }

----- C:\Dev\KARASHI\ma0\quick.go -----
// File: ma0/quick.go package ma0  import ( 	"database/sql" 	"fmt" 	"reflect" 	"strings"  	"karashi/jancode" 	"karashi/jcshms" )  // CheckOrCreateMA0 は MA0 テーブルを検索し、 // 見つかればそのまま返却。なければ JC+JA マスタ情報を // MA0Full にフルマッピングして INSERT → 返却します。 func CheckOrCreateMA0(db *sql.DB, jan string) (*MA0Full, error) { 	// 空 JAN はスキップ 	if jan == "" || strings.Trim(jan, "0") == "" { 		return nil, nil 	}  	// 1) 既存 MA0 検索 (SELECT *) 	const sel = "SELECT * FROM ma0 WHERE MA000 = ?" 	var full MA0Full 	v := reflect.ValueOf(&full).Elem() 	scanArgs := make([]interface{}, v.NumField()) 	for i := range scanArgs { 		scanArgs[i] = v.Field(i).Addr().Interface() 	} 	err := db.QueryRow(sel, jan).Scan(scanArgs...) 	if err == nil { 		// 既に登録済み 		return &full, nil 	} 	if err != sql.ErrNoRows { 		// DB エラー 		return nil, fmt.Errorf("ma0 lookup failed: %w", err) 	}  	// 2) JC/JA マスタ取得 	jc, err := jcshms.QueryByJan(db, jan) 	if err != nil { 		return nil, fmt.Errorf("jcshms lookup failed: %w", err) 	} 	ja, err := jancode.QueryByJan(db, jan) 	if err != nil { 		return nil, fmt.Errorf("jancode lookup failed: %w", err) 	}  	// 3) マッピング (どちらも存在し、YJ が取れる場合のみ登録) 	if jc != nil && jc.JC009 != "" && ja != nil && ja.JA009 != "" { 		// JC側フィールド 		full.MA000 = jc.JC000 		full.MA009 = jc.JC009 		full.MA018 = jc.JC018 		full.MA022 = jc.JC022  		full.MA037 = jc.JC037 		full.MA039 = jc.JC039 		full.MA044 = jc.JC044  		full.MA061 = jc.JC061 		full.MA062 = jc.JC062 		full.MA063 = jc.JC063 		full.MA064 = jc.JC064  		// JA側フィールド 		full.MA125 = ja.JA000 		full.MA131 = ja.JA006 		full.MA132 = ja.JA007 		full.MA133 = ja.JA008 		full.MA134 = ja.JA009  		// 4) INSERT OR IGNORE INTO ma0 		ph := make([]string, v.NumField()) 		for i := range ph { 			ph[i] = "?" 		} 		insertSQL := fmt.Sprintf("INSERT OR IGNORE INTO ma0 VALUES(%s)", strings.Join(ph, ",")) 		args := make([]interface{}, v.NumField()) 		for i := range args { 			args[i] = v.Field(i).Interface() 		} 		if _, err := db.Exec(insertSQL, args...); err != nil { 			return nil, fmt.Errorf("ma0 insert failed: %w", err) 		} 		return &full, nil 	}  	// 5) マスタ情報不足 → 登録せず nil 	return nil, nil }

----- C:\Dev\KARASHI\ma0\record.go -----
// File: ma0/record.go package ma0  import "database/sql"  // Record は日常処理で使う主要9フィールドだけを持つ軽量版 struct です。 // フィールド名はテーブルのカラム名と完全一致しています。 type Record struct { 	MA000 string // JANコード 	MA009 string // YJコード 	MA018 string // 商品名 	MA037 string // 包装形態 	MA039 string // 包装単位 	MA044 string // 包装総量 	MA131 string // JAN数量 	MA132 string // JAN単位コード 	MA133 string // YJ換算数量 }  // QueryMA0 は指定された JAN をキーに Record を取得します。 func QueryMA0(db *sql.DB, jan string) (*Record, error) { 	const sqlstr = ` SELECT   MA000,MA009,MA018,MA037,MA039,MA044,MA131,MA132,MA133 FROM ma0 WHERE MA000 = ? ` 	var r Record 	err := db.QueryRow(sqlstr, jan).Scan( 		&r.MA000, 		&r.MA009, 		&r.MA018, 		&r.MA037, 		&r.MA039, 		&r.MA044, 		&r.MA131, 		&r.MA132, 		&r.MA133, 	) 	if err == sql.ErrNoRows { 		return nil, nil 	} 	if err != nil { 		return nil, err 	} 	return &r, nil }

----- C:\Dev\KARASHI\ma2\ma2.go -----
package ma2  import ( 	"database/sql" 	"fmt"  	"karashi/jancode" 	"karashi/jcshms" )  // Record は ma2 の軽量版レコードです。 type Record struct { 	ID    int64  // AUTOINCREMENT 	MA000 string // JANコード 	MA009 string // YJコード 	MA018 string // 商品名 	MA037 string // 包装形態（未使用） 	MA039 string // 包装単位（未使用） 	MA044 string // 包装総量（未使用） 	MA131 string // JAN数量 	MA132 string // JAN単位コード 	MA133 string // YJ換算数量 	MA134 string // YJ単位コード }  // QueryByJan は ma2 を JAN で検索します。 func QueryByJan(db *sql.DB, jan string) (*Record, error) { 	const sqlstr = `         SELECT           id,           MA000, MA009, MA018,           MA037, MA039, MA044,           MA131, MA132, MA133, MA134         FROM ma2         WHERE MA000 = ?` 	var r Record 	err := db.QueryRow(sqlstr, jan).Scan( 		&r.ID, 		&r.MA000, &r.MA009, &r.MA018, 		&r.MA037, &r.MA039, &r.MA044, 		&r.MA131, &r.MA132, &r.MA133, &r.MA134, 	) 	if err == sql.ErrNoRows { 		return nil, nil 	} 	if err != nil { 		return nil, fmt.Errorf("ma2.QueryByJan failed: %w", err) 	} 	return &r, nil }  // InsertWithoutYJ は YJ以外のフィールドで INSERT。 // トリガーで MA009 が自動採番されます。 func InsertWithoutYJ(db *sql.DB, r *Record) error { 	const stmt = `         INSERT INTO ma2 (           MA000, MA018,           MA037, MA039, MA044,           MA131, MA132, MA133, MA134         ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)` 	if _, err := db.Exec(stmt, 		r.MA000, r.MA018, 		r.MA037, r.MA039, r.MA044, 		r.MA131, r.MA132, r.MA133, r.MA134, 	); err != nil { 		return fmt.Errorf("ma2.InsertWithoutYJ failed: %w", err) 	} 	return nil }  // CheckOrCreateByJan は既存レコードがなければ作成します。 // datName は DAT から渡された品名です。 func CheckOrCreateByJan(db *sql.DB, jan, datName string) (*Record, error) { 	// 1) 既存チェック 	if rec, err := QueryByJan(db, jan); err != nil { 		return nil, err 	} else if rec != nil { 		return rec, nil 	}  	// 2) マスタ参照 	jc, _ := jcshms.QueryByJan(db, jan) 	ja, _ := jancode.QueryByJan(db, jan)  	// 3) レコード構築 	rec := &Record{ 		MA000: jan, 		MA018: datName, 	} 	if jc != nil { 		rec.MA018 = jc.JC018 	} 	if ja != nil { 		rec.MA131 = ja.JA006 		rec.MA132 = ja.JA007 		rec.MA133 = ja.JA008 		rec.MA134 = ja.JA009 	}  	// 4) INSERT → トリガーで MA009 自動採番 	if err := InsertWithoutYJ(db, rec); err != nil { 		return nil, err 	}  	// 5) 採番後再取得 	return QueryByJan(db, jan) }

----- C:\Dev\KARASHI\static\css\styles.css -----
/* 余白・パディングは指定しない方針 */  body {   font-family: sans-serif; }  #output {   border: 1px solid #ccc;   background: #f9f9f9;   white-space: pre-wrap; }

----- C:\Dev\KARASHI\static\js\dat.js -----
document.addEventListener("DOMContentLoaded", () => {   const btn     = document.getElementById("datBtn");   const input   = document.getElementById("datInput");   const table   = document.getElementById("outputTable");   const thead   = table.querySelector("thead");   const tbody   = table.querySelector("tbody");   const indi    = document.getElementById("indicator");    btn.addEventListener("click", () => {     const filter = document.getElementById("aggregateFilter");     if (filter) filter.style.display = "none";      thead.innerHTML = "";     tbody.innerHTML = "";     indi.textContent = "";     input.value = null;     input.click();   });    input.addEventListener("change", async () => {     if (!input.files.length) return;     indi.textContent = "DATファイルアップロード中…";      for (let file of input.files) {       const form = new FormData();       form.append("datFileInput[]", file);        try {         const res  = await fetch("/uploadDat", { method: "POST", body: form });         const data = await res.json();          indi.textContent = `${file.name}：読み込み ${data.count} 件`;         thead.innerHTML = `           <tr>             <th>日付</th><th>JAN</th><th>YJ</th><th>商品名</th><th>包装</th>             <th>数量</th><th>JAN数</th><th>JAN単位</th><th>JAN単位CD</th>             <th>YJ数</th><th>YJ単位</th><th>単価</th><th>小計</th>             <th>税額</th><th>税率</th><th>期限</th><th>ロット</th>             <th>伝票</th><th>行</th><th>区分</th><th>得意先</th>           </tr>`;          tbody.innerHTML = "";         data.records.forEach(rec => {           const tr = document.createElement("tr");           tr.innerHTML = `             <td>${rec.slipdate}</td><td>${rec.jancode}</td><td>${rec.yjcode}</td><td>${rec.productname}</td><td>${rec.packaging}</td>             <td>${rec.datqty}</td><td>${rec.janquantity}</td><td>${rec.janunitname}</td><td>${rec.janunitcode}</td>             <td>${rec.yjquantity}</td><td>${rec.yjunitname}</td><td>${rec.unitprice}</td>             <td>${rec.subtotalamount}</td><td>${rec.taxamount}</td><td>${rec.taxrate}</td>             <td>${rec.expirydate}</td><td>${rec.lotnumber}</td><td>${rec.receiptnumber}</td>             <td>${rec.linenumber}</td><td>${rec.flag}</td><td>${rec.partnercode}</td>           `;           tbody.appendChild(tr);         });        } catch (err) {         console.error(err);         indi.textContent = "DATアップロードエラー: " + err.message;       }     }   }); });

----- C:\Dev\KARASHI\static\index.html -----
<!-- File: static/index.html --> <!DOCTYPE html> <html lang="ja"> <head>   <meta charset="UTF-8">   <title>YAMATO 集計システム</title>   <link rel="stylesheet" href="/static/css/styles.css">   <link rel="icon" href="/favicon.ico" type="image/x-icon">   <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon"> </head> <body>    <header id="header">     <div id="indicator"></div>     <nav>       <button id="datBtn" class="btn">納品・返品</button>       <button id="usageBtn" class="btn">USAGE</button>       <button id="aggregateBtn" class="btn">集計</button>       <button id="inventoryBtn" class="btn">棚卸</button>       <button id="ma2Btn" class="btn">MA2編集</button>       <button id="inoutBtn" class="btn">出庫・入庫</button>     </nav>     <div id="aggregateFilter" style="display:none">       <!-- 集計フィルタ（実装時に中身を追加） -->     </div>   </header>    <!-- ファイル選択ボタン（非表示） -->   <input type="file" id="datInput" multiple style="display:none">   <input type="file" id="usageInput" multiple style="display:none">   <input type="file" id="inventoryInput" accept=".csv" style="display:none">    <!-- データ出力テーブル -->   <table id="outputTable">     <thead></thead>     <tbody></tbody>   </table>    <pre id="debug" style="background:#f0f0f0; padding:0.5em; margin:1em 0;"></pre>    <!-- 実装済みの DAT 機能だけを読み込む -->   <script src="/static/js/dat.js"></script>  </body> </html>

----- C:\Dev\KARASHI\tani\loader.go -----
// File: tani/loader.go package tani  import ( 	"encoding/csv" 	"os" 	"strings"  	"golang.org/x/text/encoding/japanese" 	"golang.org/x/text/transform" )  // LoadTANIFile は Shift-JIS 形式の TANI.CSV を読み込み // code→name マップを返します。 func LoadTANIFile(path string) (map[string]string, error) { 	f, err := os.Open(path) 	if err != nil { 		return nil, err 	} 	defer f.Close()  	r := csv.NewReader(transform.NewReader(f, japanese.ShiftJIS.NewDecoder())) 	r.LazyQuotes = true 	rows, err := r.ReadAll() 	if err != nil { 		return nil, err 	}  	m := make(map[string]string, len(rows)) 	for _, rec := range rows { 		if len(rec) >= 2 { 			code := strings.TrimSpace(rec[0]) 			name := strings.TrimSpace(rec[1]) 			m[code] = name 		} 	} 	return m, nil }

----- C:\Dev\KARASHI\tani\resolver.go -----
// File: tani/resolver.go package tani  import "strings"  // 内部マップ var ( 	codeToName map[string]string 	nameToCode map[string]string )  // SetMaps は LoadTANIFile の結果を設定し、逆引きマップも構築します。 func SetMaps(m map[string]string) { 	codeToName = make(map[string]string, len(m)) 	nameToCode = make(map[string]string, len(m)) 	for code, name := range m { 		codeToName[code] = name 		nameToCode[name] = code 	} }  // ResolveName は単位コード→名称を返します。 // マップに存在しなければそのままコードを返します。 func ResolveName(code string) string { 	code = strings.TrimSpace(code) 	if n, ok := codeToName[code]; ok { 		return n 	} 	return code }  // ResolveCode は単位名称→コードを返します。 // マップに存在しなければ空文字を返します。 func ResolveCode(name string) string { 	name = strings.TrimSpace(name) 	if c, ok := nameToCode[name]; ok { 		return c 	} 	return "" }

----- C:\Dev\KARASHI\unifiedrecords\datparser.go -----
// File: unifiedrecords/datparser.go package unifiedrecords  import ( 	"bufio" 	"bytes" 	"database/sql" 	"io" 	"log" 	"strconv" 	"strings"  	"karashi/ma0" 	"karashi/ma2" 	"karashi/tani"  	"golang.org/x/text/encoding/japanese" 	"golang.org/x/text/transform" )  // ParseDATFile は DAT フォーマットを読み込み、 // MA0 → MA2 の順でマスタ補完しつつ Record を返します。 func ParseDATFile(r io.Reader, db *sql.DB) ([]Record, error) { 	var list []Record 	var partnerCode string 	reader := bufio.NewReader(r)  	for { 		rawLine, err := reader.ReadBytes('\n') 		if err == io.EOF { 			break 		} 		if err != nil { 			return nil, err 		}  		line := bytes.TrimRight(rawLine, "\r\n") 		if len(line) < 3 { 			continue 		}  		switch string(line[:3]) { 		case "S20": 			if len(line) >= 12 { 				partnerCode = strings.TrimSpace(string(line[3:12])) 			}  		case "D20": 			if len(line) < 121 { 				continue 			} 			field := func(start, end int) []byte { 				if len(line) >= end { 					return line[start:end] 				} 				return line[start:] 			}  			// 商品名のみ Shift-JIS→UTF-8 			rawName := field(38, 78) 			name, _, err := transform.String( 				japanese.ShiftJIS.NewDecoder(), 				string(rawName), 			) 			if err != nil { 				name = string(rawName) 			}  			rec := Record{ 				SlipDate:       strings.TrimSpace(string(field(4, 12))), 				Flag:           atoi(string(field(3, 4))), 				ReceiptNumber:  strings.TrimSpace(string(field(12, 22))), 				LineNumber:     strings.TrimSpace(string(field(22, 24))), 				JANCode:        strings.TrimSpace(string(field(25, 38))), 				ProductName:    strings.TrimSpace(name), 				DATQty:         atoi(string(field(78, 83))), 				UnitPrice:      atof(string(field(83, 92))), 				SubtotalAmount: atof(string(field(92, 101))), 				ExpiryDate:     strings.TrimSpace(string(field(109, 115))), 				LotNumber:      strings.TrimSpace(string(field(115, 121))), 				PartnerCode:    partnerCode, 			}  			// MA0 優先で補完 			if m0, err := ma0.CheckOrCreateMA0(db, rec.JANCode); err != nil { 				log.Println("ma0 lookup failed:", err) 			} else if m0 != nil { 				applyMaster0(&rec, m0) 			} else { 				// MA2 で補完 				if m2, err := ma2.CheckOrCreateByJan(db, rec.JANCode, rec.ProductName); err != nil { 					log.Println("ma2 lookup failed:", err) 				} else if m2 != nil { 					applyMaster2(&rec, m2) 				} 			}  			list = append(list, rec) 		} 	} 	return list, nil }  func applyMaster0(rec *Record, m0 *ma0.MA0Full) { 	rec.YJCode = m0.MA009 	rec.ProductName = m0.MA018 	rec.JANQuantity = atoi(m0.MA131) 	rec.JANUnitCode = m0.MA132  	// YJ数 ← MA044 	rec.YJQuantity = atof(m0.MA044)  	rec.JANUnitName = tani.ResolveName(rec.JANUnitCode)  	if rec.JANUnitCode == "" || rec.JANUnitCode == "0" { 		rec.JANUnitName = rec.YJUnitName 	}  	rec.Packaging = buildPackagingString(m0) }  func applyMaster2(rec *Record, m2 *ma2.Record) { 	rec.YJCode = m2.MA009 	rec.ProductName = m2.MA018 	rec.JANQuantity = atoi(m2.MA131) 	rec.JANUnitCode = m2.MA132  	// YJ数 ← MA044 	rec.YJQuantity = atof(m2.MA044)  	rec.JANUnitName = tani.ResolveName(rec.JANUnitCode)  	if rec.JANUnitCode == "" || rec.JANUnitCode == "0" { 		rec.JANUnitName = rec.YJUnitName 	} }  func atoi(s string) int { 	n, _ := strconv.Atoi(strings.TrimSpace(s)) 	return n }  func atof(s string) float64 { 	f, _ := strconv.ParseFloat(strings.TrimSpace(s), 64) 	return f }  // buildPackagingString は MA0 の包装総量（MA044）＋包装単位（MA039）を組み立てます。 func buildPackagingString(m *ma0.MA0Full) string { 	qty := strings.TrimSpace(m.MA044) 	unit := tani.ResolveName(m.MA039) 	if qty == "" || unit == "" { 		return "" 	} 	return qty + unit }

----- C:\Dev\KARASHI\unifiedrecords\unifiedrecords.go -----
// 統合明細構造体とDB登録処理 package unifiedrecords  import ( 	"database/sql" )  // Record は unifiedrecords テーブルに対応する1行 type Record struct { 	SlipDate       string  `json:"slipdate"` 	JANCode        string  `json:"jancode"` 	YJCode         string  `json:"yjcode"` 	ProductName    string  `json:"productname"` 	Packaging      string  `json:"packaging"` 	DATQty         int     `json:"datqty"` 	JANQuantity    int     `json:"janquantity"` 	JANUnitName    string  `json:"janunitname"` 	JANUnitCode    string  `json:"janunitcode"` 	YJQuantity     float64 `json:"yjquantity"` 	YJUnitName     string  `json:"yjunitname"` 	UnitPrice      float64 `json:"unitprice"` 	SubtotalAmount float64 `json:"subtotalamount"` 	TaxAmount      float64 `json:"taxamount"` 	TaxRate        float64 `json:"taxrate"` 	ExpiryDate     string  `json:"expirydate"` 	LotNumber      string  `json:"lotnumber"` 	ReceiptNumber  string  `json:"receiptnumber"` 	LineNumber     string  `json:"linenumber"` 	Flag           int     `json:"flag"` 	PartnerCode    string  `json:"partnercode"` }  // Insert は Record を unifiedrecords テーブルに登録する func Insert(db *sql.DB, rec Record) error { 	const stmt = ` 	INSERT INTO unifiedrecords ( 		slipdate, jancode, yjcode, productname, packaging, 		datqty, janquantity, janunitname, janunitcode, 		yjquantity, yjunitname, 		unitprice, subtotalamount, taxamount, taxrate, 		expirydate, lotnumber, receiptnumber, 		linenumber, flag, partnercode 	) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,  ?, ?, ?, ?, ?, ?) 	` 	_, err := db.Exec(stmt, 		rec.SlipDate, rec.JANCode, rec.YJCode, rec.ProductName, rec.Packaging, 		rec.DATQty, rec.JANQuantity, rec.JANUnitName, rec.JANUnitCode, 		rec.YJQuantity, rec.YJUnitName, 		rec.UnitPrice, rec.SubtotalAmount, rec.TaxAmount, rec.TaxRate, 		rec.ExpiryDate, rec.LotNumber, rec.ReceiptNumber, 		rec.LineNumber, rec.Flag, rec.PartnerCode, 	) 	return err }

----- C:\Dev\KARASHI\unifiedrecords\upload.go -----
// File: unifiedrecords/upload.go package unifiedrecords  import ( 	"database/sql" 	"encoding/json" 	"log" 	"net/http" )  // DB は main.go から渡される共有DB接続 var DB *sql.DB  // UploadDatHandler は POST でアップされた DAT ファイル群を受け取り、 // 解析・登録後に JSON を返却します。 func UploadDatHandler(w http.ResponseWriter, r *http.Request) { 	// 最大 10MB の multipart/form-data を解析 	if err := r.ParseMultipartForm(10 << 20); err != nil { 		http.Error(w, "フォーム解釈失敗", http.StatusBadRequest) 		return 	}  	files := r.MultipartForm.File["datFileInput[]"] 	all := make([]Record, 0)  	for _, fh := range files { 		f, err := fh.Open() 		if err != nil { 			log.Println("DATオープン失敗:", err) 			continue 		}  		records, err := ParseDATFile(f, DB) 		f.Close() 		if err != nil { 			log.Println("パース失敗:", err) 			continue 		}  		for _, rec := range records { 			if err := Insert(DB, rec); err != nil { 				log.Println("登録失敗:", err) 				continue 			} 			all = append(all, rec) 		} 	}  	w.Header().Set("Content-Type", "application/json") 	json.NewEncoder(w).Encode(map[string]interface{}{ 		"count":   len(all), 		"records": all, 	}) }

----- C:\Dev\KARASHI\main.go -----
// File: main.go package main  import ( 	"database/sql" 	"log" 	"net/http" 	"os/exec" 	"runtime" 	"time"  	"karashi/loader" 	"karashi/tani" 	"karashi/unifiedrecords"  	_ "github.com/mattn/go-sqlite3" )  func openBrowser(url string) { 	var cmd string 	var args []string 	switch runtime.GOOS { 	case "windows": 		cmd = "cmd" 		args = []string{"/c", "start", url} 	case "darwin": 		cmd = "open" 		args = []string{url} 	case "linux": 		cmd = "xdg-open" 		args = []string{url} 	default: 		return 	} 	exec.Command(cmd, args...).Start() }  func main() { 	// 1) DB 接続 	db, err := sql.Open("sqlite3", "yamato.db") 	if err != nil { 		log.Fatal("DB接続失敗:", err) 	} 	defer db.Close()  	// 2) schema + CSV マスター初期化 (jcshms/jancode) 	if err := loader.InitDatabase(db); err != nil { 		log.Fatal("マスター初期化失敗:", err) 	}  	// 3) 単位マスター読み込み → 逆マップを構築 	unitMap, err := tani.LoadTANIFile("SOU/TANI.CSV") 	if err != nil { 		log.Fatal("単位マスター読み込み失敗:", err) 	} 	tani.SetMaps(unitMap)  	// 4) unifiedrecords パッケージへ DB 注入 	unifiedrecords.DB = db  	// 5) 静的ファイル配信 & DAT アップロードハンドラ 	http.Handle("/static/", http.StripPrefix("/static/", http.FileServer(http.Dir("./static")))) 	http.HandleFunc("/uploadDat", unifiedrecords.UploadDatHandler) 	http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) { 		http.ServeFile(w, r, "./static/index.html") 	})  	addr := "http://localhost:8080" 	log.Println("起動完了 →", addr)  	// 6) 少し待って自動でブラウザを開く 	go func() { 		time.Sleep(200 * time.Millisecond) 		openBrowser(addr) 	}()  	// 7) サーバ起動 	log.Fatal(http.ListenAndServe(":8080", nil)) }

----- C:\Dev\KARASHI\schema.sql -----
CREATE TABLE IF NOT EXISTS unifiedrecords (      slipdate text,     jancode text,     yjcode text,     productname text,     packaging text,     datqty integer,     janquantity integer,     janunitname text,     janunitcode text,     yjquantity real,     yjunitname text,     unitprice real,     subtotalamount real,     taxamount real,     taxrate real,     expirydate text,     lotnumber text,     receiptnumber text,     linenumber text,     flag integer,     partnercode text );  CREATE TABLE IF NOT EXISTS jcshms ( JC000 TEXT, JC001 TEXT, JC002 TEXT, JC003 TEXT, JC004 TEXT, JC005 TEXT, JC006 TEXT, JC007 TEXT, JC008 TEXT, JC009 TEXT, JC010 TEXT, JC011 TEXT, JC012 TEXT, JC013 TEXT, JC014 TEXT, JC015 TEXT, JC016 TEXT, JC017 TEXT, JC018 TEXT, JC019 TEXT, JC020 TEXT, JC021 TEXT, JC022 TEXT, JC023 TEXT, JC024 TEXT, JC025 TEXT, JC026 TEXT, JC027 TEXT, JC028 TEXT, JC029 TEXT, JC030 TEXT, JC031 TEXT, JC032 TEXT, JC033 TEXT, JC034 TEXT, JC035 TEXT, JC036 TEXT, JC037 TEXT, JC038 TEXT, JC039 TEXT, JC040 TEXT, JC041 TEXT, JC042 TEXT, JC043 TEXT, JC044 TEXT, JC045 TEXT, JC046 TEXT, JC047 TEXT, JC048 TEXT, JC049 TEXT, JC050 TEXT, JC051 TEXT, JC052 TEXT, JC053 TEXT, JC054 TEXT, JC055 TEXT, JC056 TEXT, JC057 TEXT, JC058 TEXT, JC059 TEXT, JC060 TEXT, JC061 TEXT, JC062 TEXT, JC063 TEXT, JC064 TEXT, JC065 TEXT, JC066 TEXT, JC067 TEXT, JC068 TEXT, JC069 TEXT, JC070 TEXT, JC071 TEXT, JC072 TEXT, JC073 TEXT, JC074 TEXT, JC075 TEXT, JC076 TEXT, JC077 TEXT, JC078 TEXT, JC079 TEXT, JC080 TEXT, JC081 TEXT, JC082 TEXT, JC083 TEXT, JC084 TEXT, JC085 TEXT, JC086 TEXT, JC087 TEXT, JC088 TEXT, JC089 TEXT, JC090 TEXT, JC091 TEXT, JC092 TEXT, JC093 TEXT, JC094 TEXT, JC095 TEXT, JC096 TEXT, JC097 TEXT, JC098 TEXT, JC099 TEXT, JC100 TEXT, JC101 TEXT, JC102 TEXT, JC103 TEXT, JC104 TEXT, JC105 TEXT, JC106 TEXT, JC107 TEXT, JC108 TEXT, JC109 TEXT, JC110 TEXT, JC111 TEXT, JC112 TEXT, JC113 TEXT, JC114 TEXT, JC115 TEXT, JC116 TEXT, JC117 TEXT, JC118 TEXT, JC119 TEXT, JC120 TEXT, JC121 TEXT, JC122 TEXT, JC123 TEXT, JC124 TEXT, PRIMARY KEY(JC000) );  CREATE TABLE IF NOT EXISTS jancode ( JA000 TEXT, JA001 TEXT, JA002 TEXT, JA003 TEXT, JA004 TEXT, JA005 TEXT, JA006 TEXT, JA007 TEXT, JA008 TEXT, JA009 TEXT, JA010 TEXT, JA011 TEXT, JA012 TEXT, JA013 TEXT, JA014 TEXT, JA015 TEXT, JA016 TEXT, JA017 TEXT, JA018 TEXT, JA019 TEXT, JA020 TEXT, JA021 TEXT, JA022 TEXT, JA023 TEXT, JA024 TEXT, JA025 TEXT, JA026 TEXT, JA027 TEXT, JA028 TEXT, JA029 TEXT, PRIMARY KEY(JA001) );  CREATE TABLE IF NOT EXISTS ma0 ( MA000 TEXT, MA001 TEXT, MA002 TEXT, MA003 TEXT, MA004 TEXT, MA005 TEXT, MA006 TEXT, MA007 TEXT, MA008 TEXT, MA009 TEXT, MA010 TEXT, MA011 TEXT, MA012 TEXT, MA013 TEXT, MA014 TEXT, MA015 TEXT, MA016 TEXT, MA017 TEXT, MA018 TEXT, MA019 TEXT, MA020 TEXT, MA021 TEXT, MA022 TEXT, MA023 TEXT, MA024 TEXT, MA025 TEXT, MA026 TEXT, MA027 TEXT, MA028 TEXT, MA029 TEXT, MA030 TEXT, MA031 TEXT, MA032 TEXT, MA033 TEXT, MA034 TEXT, MA035 TEXT, MA036 TEXT, MA037 TEXT, MA038 TEXT, MA039 TEXT, MA040 TEXT, MA041 TEXT, MA042 TEXT, MA043 TEXT, MA044 TEXT, MA045 TEXT, MA046 TEXT, MA047 TEXT, MA048 TEXT, MA049 TEXT, MA050 TEXT, MA051 TEXT, MA052 TEXT, MA053 TEXT, MA054 TEXT, MA055 TEXT, MA056 TEXT, MA057 TEXT, MA058 TEXT, MA059 TEXT, MA060 TEXT, MA061 TEXT, MA062 TEXT, MA063 TEXT, MA064 TEXT, MA065 TEXT, MA066 TEXT, MA067 TEXT, MA068 TEXT, MA069 TEXT, MA070 TEXT, MA071 TEXT, MA072 TEXT, MA073 TEXT, MA074 TEXT, MA075 TEXT, MA076 TEXT, MA077 TEXT, MA078 TEXT, MA079 TEXT, MA080 TEXT, MA081 TEXT, MA082 TEXT, MA083 TEXT, MA084 TEXT, MA085 TEXT, MA086 TEXT, MA087 TEXT, MA088 TEXT, MA089 TEXT, MA090 TEXT, MA091 TEXT, MA092 TEXT, MA093 TEXT, MA094 TEXT, MA095 TEXT, MA096 TEXT, MA097 TEXT, MA098 TEXT, MA099 TEXT, MA100 TEXT, MA101 TEXT, MA102 TEXT, MA103 TEXT, MA104 TEXT, MA105 TEXT, MA106 TEXT, MA107 TEXT, MA108 TEXT, MA109 TEXT, MA110 TEXT, MA111 TEXT, MA112 TEXT, MA113 TEXT, MA114 TEXT, MA115 TEXT, MA116 TEXT, MA117 TEXT, MA118 TEXT, MA119 TEXT, MA120 TEXT, MA121 TEXT, MA122 TEXT, MA123 TEXT, MA124 TEXT, MA125 TEXT, MA126 TEXT, MA127 TEXT, MA128 TEXT, MA129 TEXT, MA130 TEXT, MA131 TEXT, MA132 TEXT, MA133 TEXT, MA134 TEXT, MA135 TEXT, MA136 TEXT, MA137 TEXT, MA138 TEXT, MA139 TEXT, MA140 TEXT, MA141 TEXT, MA142 TEXT, MA143 TEXT, MA144 TEXT, MA145 TEXT, MA146 TEXT, MA147 TEXT, MA148 TEXT, MA149 TEXT, MA150 TEXT, MA151 TEXT, MA152 TEXT, MA153 TEXT, MA154 TEXT, PRIMARY KEY(MA000) );  -- ma2 テーブル（軽量版9項目＋内部ID） CREATE TABLE IF NOT EXISTS ma2 (   id             INTEGER PRIMARY KEY AUTOINCREMENT,   MA000     TEXT    UNIQUE NOT NULL,   MA009     TEXT    UNIQUE,   MA018     TEXT,   MA037     TEXT,   MA039     TEXT,   MA044     TEXT,   MA131     TEXT,   MA132     TEXT,   MA133     TEXT,   MA134     TEXT );  -- 挿入後にYJコードを自動採番するトリガー CREATE TRIGGER IF NOT EXISTS trg_ma2_assign_yj AFTER INSERT ON ma2 FOR EACH ROW BEGIN   UPDATE ma2      SET MA009 = 'MA' || printf('%011d', NEW.id)    WHERE id = NEW.id; END; 

